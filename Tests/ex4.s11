tks = 177560 ; Terminal keyboard status
tkb = 177562 ; Terminal keyboard buffer
tps = 177564 ; Terminal printer status
tpb = 177566 ; Terminal printer buffer
lcs = 177546 ; Clock
asciimask = 177760 ; Will be used to convert ascii to number.

.=torg + 60  ; Setting keyboard interrupt function and hardware preference to 4.
.word rInput
.word 200

.=torg + 100 ; Setting clock interrupt function and hardware preference to 6.
.word clock
.word 300

.=torg + 1000
main:
; Initializing stack
mov pc, sp
tst -(sp)
mov #welcome, -(sp)
jsr pc, printStr ; Prints welcome message.
tst (sp)+
jsr pc, printNL ; Printing new line
mov #command, pointer ; Pointer will hold command adress.
mov #101,@#tks ; keyboard interrupt = 1 && RE = 1
w:
; Printing $ if needed
cmp putDolar, #0
bne cont1
mov #1, putDolar
jsr pc, printdol ; Printing $ if needed
cont1:
cmp gameOn, #1 ; If the game is not on, wait till it's on.
bne cont1
; Game is on
jsr pc, chkwins ; Checks if someone won.
tst gameOn ; If someone won then gameOn will be 0.
beq w
cmp turn, #1 ; Checking whose turn is it.
beq whitTurj
; Black player's turn
jsr pc, printBCP ; Printing black current player
jsr pc, printNL ; Printing new line
jsr pc, printdol ; Printing $ if needed
mov bTime, tcounter ; Setting the clock time to black player's time.
dec tcounter ; Decreasing the number of seconds by 1 becuase mili seconds counter will contain 1 second.
mov rate, msctr ; Rate will contain the number of clock interrupts per second so msctr will contain this number.
mov #100, @#lcs ;Clock is on.
cmpb #1, bPlayer ; Checking whether black player is human or computer.
bne bCpu
;Black player is Human
BHmnTrn: ; Black human turn
tst gameOn
beq endGBj ; If game on is 0 , game ended calculate wp for black player, and check who wins.
cmp #0, TIMOUT ; Checks if time ended for black player.
beq BHmnTrn ; Waiting for command from user while time is not ended.
cmp #-1., TIMOUT ; Checks if user already made a move.
beq BHTend ; Black Human Turn End
; Time is up - Game over.
jsr pc, printNL ; Printing new line
jsr pc, printNL ; Printing new line
mov #Blk, -(sp)
jsr pc, printStr ; Prints "Black ".
tst (sp)+
mov #hmn, -(sp) ; Prints "Human ".
jsr pc, printStr
tst (sp)+
mov #gameOver, -(sp) ; Prints " is out of time. Game Over."
jsr pc, printStr
tst (sp)+
jsr pc, printNL ; Prints a new line.
mov #0, TIMOUT ;Sets time out back to 0.
mov #0, @#lcs ; Turns off clock interrupts.
mov #0, gameOn ; Game End
jmp w ; Go to w, and wait till game on will be 1.
BHTend:
; Black Human Turn End
mov #0, TIMOUT ; Sets time out to 0.
jmp cont1

whitTurj: jmp whitTurn
endGBj: jmp endGameB

bCpu:
;Setting stack for recursive call.
mov #source, -(sp) ;Source will contain the address of the best move source position.
mov #dest, -(sp) ;dest will contain the address of the best move destenation position.
mov #WinParam, -(sp) ; WinParam will contain the WP of the best move found.
mov #1, Steps ; Setting steps to 1.
jsr pc, getMaxWP ; Calling recursive function.
add #6, sp ; Popping source, dest, and WinParam labels from the stack.
tst gameOn ; Checks if game is on, if game is still on update board, source, dest and WinParam.
beq endGBj ; If game on is 0, jump to end game for black player.
mov source, -(sp) ;Moves the best move source adress to the stack.
mov dest, -(sp) ;Moves the best move destenation adress to the stack.
jsr pc, movPiece ; Updating board.
add #4, sp ;Popping source and dest.
mov #0, TIMOUT ; Sets timeout to 0.
mov #0, @#lcs ; Turn off clock interrupts.
jsr pc, chgTurn ; Change turn.
jsr pc, printNL ; Printing new line
jsr pc, printNL ; Printing new line
jsr pc, printBLK ; Prints 'Black '
jsr pc, printPC ; Prints computer.
jsr pc, printMT ; Printing: 'move took '
tst -(sp)
mov bTime, -(sp)
jsr pc, asciConv ; Converts time to ascii values for time print.
tst (sp)+ ; popping time decimal value.
jsr pc, printStr ; Prints the number of seconds took for black computer move.
tst (sp)+
movb #'., @#tpb ; sending char to print
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
movb #'0, @#tpb ; sending char to print
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
movb #'\s, @#tpb ; sending char to print
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
mov #secStr, -(sp)
jsr pc, printStr ; Prints ' seconds'
tst (sp)+
mov #dotStr, -(sp)
jsr pc, printStr ; Prints '.'.
tst (sp)+
jsr pc, printB ; Print board.
jmp cont1

endGWj: jmp endGameW

whitTurn:
jsr pc, printWCP ; Printing white current player
jsr pc, printNL ; Printing new line
jsr pc, printdol ; Printing $ if needed
mov wTime, tcounter ; Setting the clock time to white player's time.
dec tcounter ; Decreasing the number of seconds by 1 because mili seconds counter will contain 1 second.
mov rate, msctr ; Rate will contain the number of clock interrupts per second so msctr will contain this number.
mov #100, @#lcs ;Clock is on.
cmpb #1, wPlayer ;Checks if the player is human or computer.
bne wCpu ; If player is computer branch to wCpu.
;White player is human
WHmnTrn: ; White human turn
tst gameOn ; If game on is 0 , game ended calculate wp for black player, and check who wins.
beq endGWj
cmp #0, TIMOUT ; Checks if time is over for white human turn.
beq WHmnTrn ; If time is not over, wait till a move is made or time will be over.
cmp #-1., TIMOUT ; Checks if a move was made.
beq WHTend ; White Human Turn End
; Time is up - Game over.
jsr pc, printNL ; Printing new line
jsr pc, printNL ; Printing new line
mov #Wht, -(sp)
jsr pc, printStr ; Prints 'White ' .
tst (sp)+
mov #hmn, -(sp)
jsr pc, printStr ; Prints 'Human ' .
tst (sp)+
mov #gameOver, -(sp)
jsr pc, printStr ; Prints " is out of time. Game Over."
tst (sp)+
jsr pc, printNL ; Prints new line.

mov #0, TIMOUT ; Sets time out back to 0.
mov #0, @#lcs ; Turs off clock interrupts.
mov #0, gameOn ; Game End.
jmp w
WHTend:
mov #0, TIMOUT ; A move was made, time out is -1, set it back to 0.
jmp cont1

wCpu:
;Setting stack for recursive call.
mov #source, -(sp) ;Source will contain the address of the best move source position.
mov #dest, -(sp) ;dest will contain the address of the best move destenation position.
mov #WinParam, -(sp) ; WinParam will contain the WP of the best move found.
mov #1, Steps ; Setting steps to 1.
jsr pc, getMaxWP ; Calling recursive function.
add #6, sp ; Popping source, dest, and WinParam labels from the stack.
tst gameOn ; Checks if game is on, if game is still on update board, source, dest and WinParam.
beq endGWj ; If game on is 0, jump to end game for white player.
mov source, -(sp) ;Moves the best move source adress to the stack.
mov dest, -(sp) ;Moves the best move destenation adress to the stack.
jsr pc, movPiece ; Updating board.
add #4, sp ;Popping source and dest.
mov #0, TIMOUT ; Sets timeout to 0.
mov #0, @#lcs ; Turn off clock interrupts.
jsr pc, chgTurn ; Change turn.
jsr pc, printNL ; Printing new line
jsr pc, printNL ; Printing new line
jsr pc, printWHT ; Prints 'White '
jsr pc, printPC ; Prints computer.
jsr pc, printMT ; Printing: 'move took '
tst -(sp)
mov wTime, -(sp)
jsr pc, asciConv  ;Converts time to ascii values for time print.
tst (sp)+ ; popping time decimal value.
jsr pc, printStr ; Prints the number of seconds took for black computer move.
tst (sp)+
movb #'., @#tpb ; sending char to print
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
movb #'0, @#tpb ; sending char to print
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
movb #'\s, @#tpb ; sending char to print
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
mov #secStr, -(sp)
jsr pc, printStr ; Prints ' seconds'
tst (sp)+
mov #dotStr, -(sp)
jsr pc, printStr ; Prints '.'.
tst (sp)+
jsr pc, printB ; Print board.
jmp cont1

endGameW:
; Game ended in white player's turn.
mov #0, @#lcs ; Turn off clock interrupts.
mov #WPfor, -(sp)
jsr pc, printStr ; Prints 'WP for ' .
tst (sp)+
mov #wplyris, -(sp)
jsr pc, printStr ; Prints 'White player is'.
tst (sp)+
; Setting stack for calcWP function.
mov r4, -(sp) ; Backing up r4, which will contain the output of calcWP.
mov #Board, -(sp) ; Moving board label to stack.
mov turn, -(sp) ; Move current player's turn.
jsr pc, calcWP ; Caculating wp for current player.
mov r4, WinParam ; Moving WP calculated from r4 to WinParam.
add #4, sp ; Popping #Board and turn from stack.
mov (sp)+, r4 ; Restoring r4's value.
jsr pc, printWP ; Prints calculated wp.
jsr pc, printNL ; Prints new line.
jsr pc, printWin ; Prints winning message or tie message.
jsr pc, printNL ; Prints new line.
jmp w

endGameB:
; Game ended in black player's turn.
mov #0, @#lcs ; Turn off clock interrupts.
mov #WPfor, -(sp)
jsr pc, printStr ; Prints 'WP for ' .
tst (sp)+
mov #bplyris, -(sp) ; Prints 'Black player is'.
jsr pc, printStr
tst (sp)+
; Setting stack for calcWP function.
mov r4, -(sp) ; Backing up r4, which will contain the output of calcWP.
mov #Board, -(sp) ; Moving board label to stack.
mov turn, -(sp) ; Move current player's turn.
jsr pc, calcWP ; Caculating wp for current player.
mov r4, WinParam ; Moving WP calculated from r4 to WinParam.
add #4, sp ; Popping #Board and turn from stack.
mov (sp)+, r4 ; Restoring r4's value.
jsr pc, printWP ; Prints calculated wp.
jsr pc, printNL ; Prints new line.
jsr pc, printWin ; Prints winning message or tie message.
jsr pc, printNL ; Prints new line.
jmp w

rInput: ; Read input - keyboard interrupt function.
movb @#tkb, curChar ;Moving entered char from tkb to curChar.
; Check if we reached the end of the command
mov r0, -(sp) ; Backing up r0
mov #command, r0 ; Moving command string address to r0
add #49., r0 ; Adding max length of string to r0.
cmp pointer, r0 ; Checks if the command reached 50 chars.
bgt ignore ; Ignore the input if command length is 50 or more.
; We have not reached the end of the command
cmpb curChar, #'\r  ; checks if current char is ENTER
beq endOfIpt ; If the current char is ENTER go to endOfIpt.
cmpb #'\b, curChar  ; checks if current char is BackSpace
beq backspace ; If the char is backspace, delete last char.
; Current char is a neither ENTER nor BackSpace
movb curChar, @pointer ;Save current char in command.
movb curChar, @#tpb ; sending char to print.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
; curChar was printed
inc pointer ; Pointer will point the next available spot in command string.
mov (sp)+, r0 ; Restores r0.
inc @#tks ; RE = 1
rti

endOfIpt:
jsr pc, printNL ; Printing new line
movb #0, @pointer ; Adds 0 to the command string.
mov #command, pointer ; Pointer will point the beginning of the command
mov (sp)+, r0 ; Restoring r0
jsr pc, decode ; Decoding the command
mov #command, pointer ; Pointer will point the beginning of the command
mov #0, putDolar ; Dollar should be printed.
inc @#tks ; RE = 1
rti

backspace:
cmp #command, pointer ; Checks if the command reached 50 chars.
beq ignore ; Ignore the input if command length is 50 or more.
dec pointer ; Pointer will now point to the previous char.
movb #'\b, @#tpb ; Moving cursor to the previous char.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
movb #' , @#tpb ; Prints ' '.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
movb #'\b, @#tpb ; Moving cursor to the previous char.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
inc @#tks ; RE = 1
mov (sp)+, r0 ; Restoring r0
rti

ignore:
mov (sp)+, r0 ; Restoring r0
inc @#tks ; RE = 1
rti

decode:
cmpb @pointer, #'s ; Checks if the first char that was entered was 's'.
beq sCom ; Branch to s command.
cmpb @pointer, #'t ; Checks if the first char that was entered was 't'.
beq tCom ; Branch to t command.
cmpb @pointer, #'m ; Checks if the first char that was entered was 'm'.
beq mCom ; Branch to m command.
jmp noCom ; The first  wasn't: 's', 't', or 'm' so it's an illegal command.

sCom:
;The first char that was entered was the letter s.
inc pointer ; Pointer will now point to the second char in #command.
cmpb @pointer, #'t ; Checks if the second char that was entered was 't'.
bne noCom ; The second char that was entered wasn't 't' so it's an illegal command.
inc pointer ; Pointer will now point to the third char in #command.
cmpb @pointer, #'a ; Checks if the third char that was entered was 'a'.
beq staCom ; The three chars that were entered were 's', 't', 'a', branch to stacom to check if 'start' was entered.
cmpb @pointer, #'o ; Checks if the third char that was entered was 'o'.
bne noCom ; The third char that was entered wasn't 'a' or 'o' so it's an illegal command.
; If we got here we had the sequence 'sto'
inc pointer ; Pointer will now point to the fourth char in #command.
cmpb @pointer, #'p ; Checks if the fourth char that was entered was 'p'.
bne noCom ; The fourth char that was entered wasn't 'p' so it's an illegal command.
jmp stopCom ; 'stop' was entered.

staCom:
; If we got here we had the sequence 'sta'
inc pointer ; Pointer will now point to the fourth char in #command.
cmpb @pointer, #'r ; Checks if the fourth char that was entered was 'r'.
bne noCom ; The fourth char that was entered wasn't 'r' so it's an illegal command.
inc pointer ; Pointer will now point to the fifth char in #command.
cmpb @pointer, #'t ; Checks if the fifth char that was entered was 't'.
bne noCom ; The fifth char that was entered wasn't 't' so it's an illegal command.
inc pointer ; Pointer will now point to the sixth char in #command.
cmpb #' , @pointer ;Checks if the char that was entered after 'start' was ' '.
bne noCom ;If the char that was entered after 'start' wasn't ' ' the command is illegal.
jmp startCom ; 'start ' was entered.

tCom:
; If we got here we had 't'
inc pointer ; Pointer will now point to the second char in #command.
cmpb @pointer, #'i ; Checks if the second char that was entered was 'i'.
bne noCom ; The second char that was entered wasn't 'i' so it's an illegal command.
inc pointer ; Pointer will now point to the third char in #command.
cmpb @pointer, #'m ; Checks if the third char that was entered was 'm'.
bne noCom ; The third char that was entered wasn't 'm' so it's an illegal command.
inc pointer ; Pointer will now point to the fourth char in #command.
cmpb @pointer, #'e ; Checks if the third char that was entered was 'e'.
bne noCom ; The fourth char that was entered wasn't 'e' so it's an illegal command.
jmp timeCom ;'time' was entered.

mCom:
; If we got here we had 'm'
inc pointer ; Pointer will now point to the second char in #command.
cmpb @pointer, #'o ; Checks if the second char that was entered was 'o'.
bne noCom ; The second char that was entered wasn't 'o' so it's an illegal command.
inc pointer ; Pointer will now point to the third char in #command.
cmpb @pointer, #'v ; Checks if the third char that was entered was 'v'.
bne noCom ; The third char that was entered wasn't 'v' so it's an illegal command.
inc pointer ; Pointer will now point to the fourth char in #command.
cmpb @pointer, #'e ; Checks if the fourth char that was entered was 'e'.
bne noCom ; The fourth char that was entered wasn't 'e' so it's an illegal command.
inc pointer ; Pointer will now point to the fifth char in #command.
cmpb #' , @pointer ;Checks if ' ' was entered after 'move'.
bne noCom ; ' ' wasn't entered after move so it's an illegal command.
jmp moveCom ; 'move ' was entered.

;-------------------------------------------------------------------------------
;                           Illegal command
;-------------------------------------------------------------------------------
noCom:
jsr pc, printNL ; Printing new line
mov #cannot, -(sp)
jsr pc, printStr ; Prints 'Cannot execute "'.
tst (sp)+
mov #command, pointer ; Moving pointer to the start of the command string.
mov #errorCom, errPtr ; Moving error command adress to error pointer.
cpyErr:
;Copying command to #errorCom.
cmpb  #0 , @pointer ; Checks if reached end of command string.
beq donecpy ; If reached end of command string branch to donecpy.
movb @pointer, @errPtr ; Copy current char from #command to #errorCom.
inc errPtr ; Move to the next char.
inc pointer ; Move to the next char.
jmp cpyErr ; Keep on copying.

donecpy:
;Command copying is done.
movb #'", @errPtr ; Put '"' char at the end of the copied command.
inc errPtr ; Move to the next char in #errorCom.
movb #'\r, @errPtr ; Put '\r' char after '"' in order to use printStr.
mov #errorCom, -(sp)
jsr pc, printStr ; Print '[command] "'.
tst (sp)+
mov #command, pointer ;Set pointer to the start of #command.
jsr pc, printNL ; Printing new line
jsr pc, printdol ; Prints '$'.
rts pc ; return from decode
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                           Command is 'start'
;-------------------------------------------------------------------------------
startCom:
cmp gameOn, #0
bne noCom ; If game is on 'start' is illegal command.
inc pointer
cmpb  #' , @pointer
beq startCom ; skipping spaces
; Spaces skipped
setWplyr: ; Set white player
cmpb @pointer, #'h ;Player is white human.
beq wHuman
cmpb @pointer, #'c ; Player is white computer.
beq wPC
jmp noCom ;The entered char wasn't 'c' or 'h' so it's an illegal command.

wHuman:
mov #1, wPlayer ;1 will represent a human player.
inc pointer ; Move to the next char.
cmpb #' , @pointer ; Checks if after 'h' there is a space. if not -> noCom
bne noCom
dec pointer ; Move to the previous char (used to skip spaces).
jmp setwTime ; Player is set, move to time set.
wPC:
mov #2, wPlayer ;2 will represent a computer player.
; Checks if after 'c' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer ; Checks if after 'c' there is a space. if not -> noComb
bne noCom
dec pointer ; Move pointer to the previous char in #command (used to skip spaces).
jmp setwTime ; Player is set, move to time set.

setwTime:
mov #0, wTime ; Reset white time.
inc pointer ; Move to the next char in #command.
cmpb #' , @pointer
beq setwTime ; skipping spaces
cmpb @pointer, #'0
blt noCom ; jumps if not a number
cmpb @pointer, #'9
bgt noCom ; jumps if not a number
jsr pc, RstBWStr ; Reseting values of wTimeStr and bTimeStr
; If we got here it is a number
rdWTime: ; Read White player time
mov r1, -(sp) ; Backing up r1
mov wTime, r1
mul #10., r1 ; r1 = wTime * 10.
mov r1, wTime ; wTime = wTime * 10.
mov (sp)+, r1 ; Restoring r1's value.
mov r0, -(sp) ; Backing up r0.
movb @pointer, @wTimePtr ; copy ascii number to a string (will be printed later)
inc wTimePtr ; Move to the next char in #wTimeStr.
movb @pointer, r0 ; r0 will hold the current char in #command (which is a number char).
;Converts number char to its ascii value.
bic #asciimask, r0
add r0, wTime ; wTime = wTime + ascii value of the current number char.
mov (sp)+, r0 ; Restoring r0's value.
inc pointer ; Move to the the next char in #command.
cmpb #' , @pointer
beq setBplyr ; If the char after number is ' ' move to set black player time.
cmpb @pointer, #'0
blt jnoCom ; jumps if not a number
cmpb @pointer, #'9
bgt jnoCom ; jumps if not a number
jmp rdWTime ; If the next char is also a number char repeat rdWTime.

setBplyr:
inc pointer ; Move to the next char in #command.
cmpb  #' , @pointer
beq setBplyr ; skipping spaces
cmpb @pointer, #'h ;Player is black human.
beq bHuman
cmpb @pointer, #'c ;Player is black computer.
beq bPC
jmp noCom ;The entered char wasn't 'c' or 'h' so it's an illegal command.

bHuman:
mov #1, bPlayer ;1 will represent a human player.
; Checks if after 'h' there is a space. if not -> noCom
inc pointer ; Move to the the next char in #command.
cmpb #' , @pointer ; Checks if after 'h' there is a space. if not -> noCom
bne jnoCom
dec pointer ; Move to the previous char in #command (used to skip spaces).
jmp setbTime ; Player is set, move to time set.

bPC:
mov #2, bPlayer ;2 will represent a computer player.
; Checks if after 'c' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer; Checks if after 'c' there is a space. if not -> noComb
bne jnoCom
dec pointer ; Move pointer to the previous char in #command (used to skip spaces).
jmp setbTime ; Player is set, move to time set.

                  jnoCom: jmp noCom
setbTime:
mov #0, bTime ; Reset black time.
inc pointer ; Move to the next char in #command.
cmpb #' , @pointer
beq setbTime ; skipping spaces
cmpb @pointer, #'0
blt jnoCom ; jumps if not a number
cmpb  @pointer, #'9
bgt jnoCom ; jumps if not a number
; If we got here it is a number
rdBTime: ; Read Black player time
mov r1, -(sp) ; Backing up r1
mov bTime, r1
mul #10., r1 ; r1 = bTime * 10.
mov r1, bTime ; bTime = bTime * 10.
mov (sp)+, r1 ; Restoring r1's value.
mov r0, -(sp) ; Backing up r0
movb @pointer, @bTimePtr ; copy ascii number to a string (will be printed later)
inc bTimePtr  ; Move to the next char in #bTimeStr.
movb @pointer, r0 ; r0 will hold the current char in #command (which is a number char).
;Converts number char to its ascii value.
bic #asciimask, r0
add r0, bTime ; bTime = bTime + ascii value of the current number char.
mov (sp)+, r0 ; Restoring r0's value.
inc pointer ; Move to the the next char in #command.
cmpb @pointer, #'0
blt startChk ; jumps if not a number
cmpb @pointer, #'9
bgt startChk ; jumps if not a number
jmp rdBTime ; If the next char is also a number char repeat rdWBTime.

startChk:
cmpb @pointer, #0 ;Check if reached the on of the command.
bne jnoCom ; If not reached end of the command, command is illegal.
jmp startOK

startOK:
mov #1, gameOn
jsr pc, printNL ; Printing new line
jsr pc, Start ; Start game routine.
rts pc ; Return from decode

Start:
mov #newgame, -(sp)
jsr pc, printStr ; Prints 'Starting a new game'.
tst (sp)+
jsr pc, printNL ; Printing new line
jsr pc, printWPI ; Printing "White player is "
cmpb #1, wPlayer
beq wplyrHmn ; White Player Human
; White player is computer
jsr pc, printPC ; Printing "Computer "
br wplyrtime ; White Player Time
wplyrHmn:
; White player is human
jsr pc, printHmn ; Printing "Human "
br wplyrtime

wplyrtime:
; Printing time for white player
mov #with, -(sp)
jsr pc, printStr ; Prints 'with '
tst (sp)+
jsr pc, printWPT ; print White Player Time
jsr pc, printSPM ; Printing "seconds per move\r"
jsr pc, printNL ; Printing new line
jsr pc, printBPI ; Printing "Black player is "
cmpb bPlayer, #1
beq bplyrHmn ; Black Player Human
; Black player is Computer
jsr pc, printPC ; Printing "Computer "
br bplyrtime
bplyrHmn:
; Black player is Human
jsr pc, printHmn ; Printing "Human "
br bplyrtime

bplyrtime:
; Printing time for black player
mov #with, -(sp)
jsr pc, printStr ; Prints 'with '
tst (sp)+
jsr pc, printBPT ; print Black Player Time
jsr pc, printSPM ; Printing "seconds per move\r"
jsr pc, printNL ; Printing new line
mov #1, turn ; White player will begin.
mov #0, tcounter ; Resets seconds time counter.
mov #0, msctr ; Resets mili seconds time counter.
mov #0, WinParam ; Resets WinParam.
jsr pc, initBoard ; Initializing the board
jsr pc, printB ; Printing the board
rts pc ; Return from decode
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            jnoCom1: jmp noCom
;-------------------------------------------------------------------------------
;                           Command is 'stop'
;-------------------------------------------------------------------------------
stopCom:
inc pointer ; Move to the next char in #command.
cmpb @pointer, #0 ;Check if reached the on of the command.
bne jnoCom1 ; If not reached end of the command, command is illegal.
tst gameOn
beq jnoCom1 ; If game on is 0, stop command is illegal.
mov #0, gameOn ; Stopping the game
jsr pc, printNL ; Prints new line.
rts pc ; Return from decode
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                           Command is 'time'
;-------------------------------------------------------------------------------
timeCom:
inc pointer ; Move to the next char in #command.
cmpb @pointer, #0 ;Check if reached the on of the command.
bne jnoCom1 ; If not reached end of the command, command is illegal.
tst gameOn
beq jnoCom1 ; If game on is 0, time command is illegal.
jsr pc, printNL ; Prints new line.
mov #tlefstr, -(sp) ; Prints 'Time Left: '.
jsr pc, printStr
; The place allocated for tleftstr will be used for the output of asciConv.
mov tcounter, -(sp) ; Moves seconds left to the stack.
jsr pc, asciConv ; Converts seconds left to number chars.
tst (sp)+ ; popping time decimal value.
jsr pc, printStr ; Prints seconds left.
tst (sp)+
movb #'., @#tpb ;Prints dot.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
mov r0, -(sp) ; Backing up r0.
mov r1, -(sp) ; Backing up r1.
clr r0
mov msctr, r1 ; Move clock interrupts left to r1.
div rate, r0 ; Clock interrupts left/rate = mili seconds left.
mov r1, -(sp) ; Moving mili seconds left to stack.
mov 2(sp), r1 ; Restoring r1's value.
mov 4(sp), r0 ; Restoring r0's value.
mov (sp)+, (sp) ; Moving mili seconds left down in the stack.
; 2(sp) will be used for output.
jsr pc, asciConv
tst (sp)+ ; popping time decimal value.
jsr pc, printStr ; Prints mili seconds left.
movb #' , @#tpb ;Prints dot.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
mov #secStr, (sp)
jsr pc, printStr ; Prints 'seconds '.
tst (sp)+
jsr pc, printNL ; Prints new line.
jsr pc, printNL ; Prints new line.
jsr pc, printdol ; Prints dollar.
rts pc ; Return from decode
;-------------------------------------------------------------------------------
;                           Command is 'move'
;-------------------------------------------------------------------------------
moveCom:
; The command is 'move'
cmp gameOn, #0 ; Check if game is on.
beq jnoCom1 ; If game on is 0, cannot move.
cmp #1, turn
beq chkwht ; If turn is 1 it's white player's turn.
;player is black.
cmp #2, bPlayer
beq jnoCom1 ; If its black player's turn and black player is computer, cannot move.
br .+12 ; Branch to continue.
chkwht:
cmp #2, wPlayer
beq jnoCom1 ; If its white player's turn and white player is computer, cannot move.
cmpb  #' , @pointer
bne continue
inc pointer ; Skipping spaces.
br chkwht
continue:
cmpb @pointer, #'0
blt jnoCom1 ; jumps if not a number
cmpb  @pointer, #'7
bgt jnoCom1 ; jumps if not a number
mov r0, -(sp)  ; Backing up r0.
mov r1, -(sp)  ; Backing up r1.
mov r2, -(sp)  ; Backing up r2.
mov r3, -(sp)  ; Backing up r3.
mov r4, -(sp)  ; Backing up r4.
mov r5, -(sp)  ; Backing up r5.
clr r1
movb @pointer, r0 ; r0 will hold the current char in #command (which is a number char).
;Converts number char to its ascii value.
bic #asciimask, r0
mov r0, r2 ; r2 will be used for row index (contains the left number of index input).
mov r0, r1 ; r1 will contain the left number of the index input.
;Multiplying r1 by 8.
asl r1
asl r1
asl r1
inc pointer ;Get next index character.
cmpb @pointer, #'0
blt badIdxj ; jumps if not a number
cmpb  @pointer, #'7
bgt badIdxj ; jumps if not a number
movb @pointer, r0 ; r0 will hold the current char in #command (which is a number char).
;Converts number char to its ascii value.
bic #asciimask, r0
mov r0, r3 ; r3 will be used for column index (contains the right number of the index input).
add r0, r1 ; r1 will contain the entered index input.
mul #2, r1 ;Multiplying by 2 (each word is 2 bytes).
add #Board, r1 ; r1 will contain the entered source index board adress.
mov r1, source ; source will hold the source index board adress.
cmp (r1), turn ;Checks if a piece of the current player is found in the given index board adress.
bne badIdxj ; The given index board adress doesn't contain a piece of the color of the current player.
inc pointer ;Get next index character.
cmpb @pointer, #'\s ;Check if the char after the number is ' '.
bne badIdxj ; The char is not ' ', the command is illegal.
skip:
cmpb  #' , @pointer
bne cont2
inc pointer ; Skipping spaces.
br skip
cont2:
cmpb @pointer, #'0
blt badIdxj ; jumps if not a number
cmpb  @pointer, #'7
bgt badIdxj ; jumps if not a number
clr r1 ; Clears r1.
movb @pointer, r0 ; r0 will hold the current char in #command (which is a number char).
;Converts number char to its ascii value.
bic #asciimask, r0
add r0, r1 ; r1 will contain the left number of the index input.
;Multiplying r1 by 8.
asl r1
asl r1
asl r1
inc pointer ;Get next index character.
cmpb @pointer, #'0
blt badIdxj ; jumps if not a number
cmpb @pointer, #'7
bgt badIdxj ; jumps if not a number
movb @pointer, r0 ; r0 will hold the current char in #command (which is a number char).
;Converts number char to its ascii value.
bic #asciimask, r0
add r0, r1 ; r1 will contain the entered index input.
mul #2, r1 ;Multiplying by 2 (each word is 2 bytes).
add #Board, r1 ; r1 will contain the entered destenation index board adress.
mov r1, dest ;dest will now hold desteation board adress.
inc pointer ;Get next index character.
cmpb @pointer, #0 ;Check if the char after the number is ' '.
bne badIdxj ; The char is not ' ', the command is illegal.
cmp dest, source ; Checks if source == dest.
beq badIdxj ; If source == dest , command is illegal.
cmp #1, turn
bne bIdxChk ; If turn is not 1 , it's black player's turn.
;Checking if the desteation adress is legal for white player.
cmp source, dest
blt badIdxj ; If source<dest white is trying to move down instead of up.
mov r2, r4 ; Using r4 as temporary row index.
sub #1, r4 ; Reducing row index by 1.
cmp r4, #0
blt badIdxj ; If row index is less than 0, cannot move left or right.
mov r3, r5 ; Using r5 as temporary column index.
add #1, r5 ; Increasing column index by 1.
cmp r5, #7
bgt LeftWmv ; If column index is bigger than 7, the current piece cannot move right. Check moves to the left.
; If we got here the desteation index can be the upper right cell.
mov source, r1 ; r1 = source board adress.
cmp -14.(r1), #1 ; Checking if the upper right piece is white.
beq LeftWmv ; If the upper right piece is white, cannot go there, check legal moves to the left.
cmp -14.(r1), #2 ; Checking if the upper right piece is black.
beq eatrwmv ; If the upper right piece is black, check if the white piece can eat it.
; If we got here the white piece can move to the upper right cell and we need to check if the desteation adress equals to the left right cell adress.
sub #14., r1 ; r1 will contain the adress of the upper right cell.
cmp r1, dest ; Checks if the upper right cell == dest.
beq destFj ; If dest is the upper right cell , the move is legal, branch to dest found.
jmp LeftWmv ; Keep on checking legal moves to the left (cannot eat so we don't need to check an eating option).

badIdxj:
  jmp badIdx

destFj:
  jmp destFound

eatrwmv:
sub #1, r4 ; Reducing row index by 1.
cmp r4, #0
blt LeftWmv ; If r4 is less than 0, cannot eat (out of bounds). Check legal moves to the left.
add #1, r5 ;Increasing column index by 1.
cmp r5, #7
bgt LeftWmv ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the left.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, we need to check if it is empty.
mov source, r1 ; r1 = source board adress.
cmp -28.(r1), #0 ; Checking if the cell is empty.
bne LeftWmv ; If the cell is not empty, cannot eat. Check legal moves to the left.
; If we got here we need to check if dest == upper right cell (after eating).
sub #28., r1 ; r1 will contain the adress of the upper right cell (after eating).
cmp dest, r1 ; Checks if the upper right cell (after eating) == dest.
beq destFj ; If dest is the upper right cell (after eating) , the move is legal, branch to dest found.

LeftWmv:
mov r2, r4 ; Putting index of the current row in r4.
sub #1, r4 ; Reducing row index by 1.
mov r3, r5 ; Putting index of the current column in r5.
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt badIdxj ; If column index is less than 0, cannot move right, dest is not a legal cell adress.
mov source, r1 ; r1 = source board adress.
cmp -18.(r1), #1 ; Checking if the upper left piece is white.
beq badIdxj ; If the upper left piece is white, cannot move there, dest is not a legal cell adress.
cmp -18.(r1), #2 ; Checking if the upper left piece is black.
beq eatlwmv ; If the upper left piece is black, Check if the white piece can eat it.
sub #18., r1 ; r1 will contain the adress of the upper left cell.
cmp dest, r1 ; Checks if the upper left cell == dest.
beq destFj ; If dest is the upper left cell , the move is legal, branch to dest found.
jmp badIdxj ; If we got here there are no more moves to check for the white player and desteation is illegal.

eatlwmv:
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt badIdxj ; If column index is less than 0, cannot eat, dest is not a legal cell adress.
sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt badIdxj ; If r3 is less than 0, cannot eat (out of bounds). dest is not a legal cell adress.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
mov source,r1 ; r1 = source board adress.
cmp -36.(r1), #0 ; Checking if the cell is empty.
bne badIdxj ; If the cell is not empty, cannot eat and dest wasn't found. Dest is illegal.
sub #36., r1 ; r1 will contain the adress of the upper left cell (after eating).
cmp dest, r1 ; Checks if the upper left cell (after eating) == dest.
beq destFound; If dest is the upper left cell (after eating) , the move is legal, branch to dest found.
jmp badIdxj ; No more moving options. Dest is not a legal move adress.

bIdxChk:
cmp source, dest
bgt badIdxj ; If source>dest black is trying to move up instead of down.
mov r2, r4 ; Putting index of the current row in r4.
add #1, r4 ; Increasing row index by 1.
cmp r4, #7
bgt badIdxj ; If row index is bigger than 7, cannot move left, dest adress cannot be legal.
mov r3, r5 ; Setting r5 to the current column index (after changing it eariler).
add #1, r5 ; Increasing column index by 1.
cmp r5, #7
bgt RightBmv ; If column index is bigger than 7, the current piece cannot move left, Check legal moves to the right.
mov source, r1 ; r1 = source board adress.
cmp 18.(r1), #2 ; Checking if the lower left piece is black.
beq RightBmv ; If the lower left piece is black, cannot go there, Check legal moves to the right.
; If we got here the desteation index can be the lower left cell.
cmp 18.(r1), #1 ; Checking if the lower left piece is black.
beq eatlbmv ; If the lower left piece is white, check if the black piece can eat it.
add #18., r1 ; r1 will contain the adress of the lower left cell.
cmp dest, r1 ; Checks if the lower left cell == dest.
beq destFound ; If dest is the lower left cell , the move is legal, branch to dest found.
br RightBmv ; Keep on checking legal moves to the right (cannot eat so we don't need to check an eating option).

eatlbmv:
add #1, r4 ; Increasing row index by 1.
cmp r4, #7 ; If r3 is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
bgt RightBmv
add #1, r5 ;Increasing column index by 1.
cmp r5, #7
bgt RightBmv ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
;If we got here, the cell which the current black piece should be placed after eating is in the board bounds, we need to check if it is empty.
mov source, r1 ; r1 = source board adress.
cmp 36.(r1), #0 ; Checking if the cell is empty.
bne RightBmv ; If the cell is not empty, cannot eat. Check legal moves to the right.
add #36., r1 ; r1 will contain the adress of the lower left cell (after eating).
cmp dest, r1 ; Checks if the lower left cell (after eating) == dest.
beq destFound ; If dest is the lower left cell (after eating), the move is legal, branch to dest found.

RightBmv:
mov r2, r4 ; Putting index of the current row in r3.
add #1, r4 ; Increasing row index by 1.
mov r3, r5 ; Putting index of the current column in r5.
sub #1, r5 ; Decreasing column index by 1.
cmp r5, #0
blt badIdxju ; If column index is less than 0, cannot move right, desteation adress cannot be legal.
mov source, r1 ; r1 = source board adress.
cmp 14.(r1), #2 ; Checking if the lower right piece is black.
beq badIdxju ; If the lower right piece is white, cannot move there, desteation adress cannot be legal.
cmp 14.(r1), #1 ; Checking if the lower right piece is white.
beq eatrbmv ; If the lower right piece is white, check if the black piece can eat it.
add #14., r1 ; r1 will contain the adress of the lower right cell.
cmp dest, r1 ; Checks if the lower right cell == dest.
beq destFound ; If dest is the lower right cell , the move is legal, branch to dest found.
jmp badIdxj ;No more moving options, dest wasn't found , dest is illegal board adress.

badIdxju: jmp badIdx

eatrbmv:
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt badIdxju ; If column index is less than 0, cannot eat, desteation adress cannot be legal.
add #1, r4 ; Increasing row index by 1.
cmp r4, #7
bgt badIdxju ; If r3 is bigger than 7, cannot eat (out of bounds). desteation adress cannot be legal.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
mov source, r1 ; r1 = source board adress.
cmp 28.(r1), #0 ; Checking if the cell is empty.
bne badIdxju ;If the cell is not empty, cannot eat.
add #28., r1 ; r1 will contain the adress of the lower right cell (after eating).
cmp dest, r1 ; Checks if the lower right cell (after eating) == dest.
beq destFound ; If dest is the lower right cell (after eating), the move is legal, branch to dest found.
jmp badIdxj ;No more moving options, dest wasn't found , dest is illegal board adress.

destFound:
; If we got here , source and desteation index were legal.
mov (sp)+, r5 ;Restores r5's value.
mov (sp)+, r4 ;Restores r4's value.
mov (sp)+, r3 ;Restores r3's value.
mov (sp)+, r2 ;Restores r2's value.
mov (sp)+, r1 ;Restores r1's value.
mov (sp)+, r0 ;Restores r0's value.
; Setting stack for movPiece which will update the board.
mov source, -(sp)
mov dest, -(sp)
jsr pc, movPiece
add #4, sp ;Popping source and dest.
mov #0, @#lcs ; Stopping the clock
mov #-1., TIMOUT ; Player Moved successfully.
jsr pc, printNL ; Printing new line
cmp turn, #1
beq whitMv ; If turn == 1 it's white player's turn.
; Black Player Turn
jsr pc, printBLK ; Printing: 'Black '
jsr pc, printHmn ; Printing: 'Human '
jsr pc, printMT ; Printing: 'move took '
tst -(sp)
mov bTime, -(sp)
add #1, tcounter
sub tcounter, (sp) ; (sp) will contain how much seconds passed in decimal.
jsr pc, asciConv ; Converting seconds passed to ascii. Output string pointer be at 2(sp).
tst (sp)+ ; popping time decimal value.
jsr pc, printStr ; Priting seconds passed.
tst (sp)+
movb #'., @#tpb ;Prints dot.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
mov r0, -(sp) ; Backing up r0.
mov r1, -(sp) ; Backing up r1.
clr r0
mov rate, r1 ; Moving number of clock interrupt per second to r1.
sub msctr, r1 ; r1 will contain how much clock interrupts passed till a seconds is passed.
div rate, r0 ; Clock interrupts passed/rate = mili seconds passed.
mov r1, -(sp) ; Moving mili seconds passed to stack.
mov 2(sp), r1 ; Restoring r1's value.
mov 4(sp), r0 ; Restoring r0's value.
mov (sp)+, (sp) ; Moving mili seconds passed down in the stack.
jsr pc, asciConv ; Converting mili seconds passed to ascii. Output string pointer be at 2(sp).
tst (sp)+ ; popping time decimal value.
jsr pc, printStr ; Prints mili seconds passed.
tst (sp)+
jmp zibby

whitMv:
;White player's turn.
jsr pc, printWHT ; Printing: 'White '
jsr pc, printHmn ; Printing: 'Human '
jsr pc, printMT ; Printing: 'move took '
tst -(sp)
mov wTime, -(sp)
add #1, tcounter
sub tcounter, (sp) ; (sp) will contain how much seconds passed in decimal.
jsr pc, asciConv ; Converting seconds passed to ascii. Output string pointer be at 2(sp).
tst (sp)+ ; popping time decimal value.
jsr pc, printStr ; Priting seconds passed.
tst (sp)+
movb #'., @#tpb ;Prints dot.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
mov r0, -(sp) ; Backing up r0.
mov r1, -(sp) ; Backing up r1.
clr r0
mov rate, r1 ; Moving number of clock interrupt per second to r1.
sub msctr, r1 ; r1 will contain how much clock interrupts passed till a seconds is passed.
div rate, r0 ; Clock interrupts passed/rate = mili seconds passed.
mov r1, -(sp) ; Moving mili seconds passed to stack.
mov 2(sp), r1 ; Restoring r1's value.
mov 4(sp), r0 ; Restoring r0's value.
mov (sp)+, (sp) ; Moving mili seconds passed down in the stack.
jsr pc, asciConv ; Converting mili seconds passed to ascii. Output string pointer be at 2(sp).
tst (sp)+ ; popping time decimal value.
jsr pc, printStr ; Prints mili seconds passed.
tst (sp)+
zibby:
movb #' , @#tpb ;Prints ' '.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
mov #secStr, -(sp) ; Prints 'seconds '.
jsr pc, printStr
tst (sp)+
mov #dotStr, -(sp) ; Prints '.'.
jsr pc, printStr
tst (sp)+
jsr pc, printB ; Printing Board
jsr pc, chgTurn ; Changing turn.
rts pc

badIdx:
;If we got here source / destenation index is illegal.
mov (sp)+, r5 ; Restoring r5's value.
mov (sp)+, r4 ; Restoring r4's value.
mov (sp)+, r3 ; Restoring r3's value.
mov (sp)+, r2 ; Restoring r2's value.
mov (sp)+, r1 ; Restoring r1's value.
mov (sp)+, r0 ; Restoring r0's value.
jmp noCom ; Source/dest is not legal, jump to no command.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                           Clock interrupt
;-------------------------------------------------------------------------------
clock:
dec msctr ;msctr will contain the number of clock interrupts in a second.
tst msctr ; If msctr == 0 a second passed.
beq .+4 ; If a second passed check seconds left.
rti
tst tcounter
beq .+16
dec tcounter ; A second passed, decrease seconds counter by 1.
mov rate, msctr ; Seconds left > 0 , set msctr to the number of clock interrupts in a second.
rti
mov #1, TIMOUT ; No seconds left, set timeout to 1.
rti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;===============================================================================
;                                FUNCTIONS
;===============================================================================
;-------------------------------------------------------------------------------
;                                movPiece
;-------------------------------------------------------------------------------
; This method will move a player from the source position to the destanation
; position.
;
; Input:
; 1. Destination position - will be stored at 2(sp).
; 2. Source position - will be stored at 4(sp).

movPiece:
 mov r1, -(sp) ; Backing up  r1.
 mov r3, -(sp) ; Backing up  r3.
 mov 10(sp), r1 ; r1 = Adress of source position.
 mov 6(sp), r3 ; r3 = Adress of destanation position.

 ; Making the changes.
 mov (r1), (r3) ; board[dest] = board[source].
 mov #0, (r1) ; board[source] = 0.

 ; Now we need to check if there was an eat. We will find the address
 ; in the middle between the source address and the dest address.
 ; Notice that if there was an eat then the address of the eaten cell
 ; is a multiply of 2 and is equal to: (src_addr + dest_addr)/2 .
 ; In that case we also need to put 0 in that place.
 ; If there was no eat then the address of the middle cell is not a
 ; multiply of 2 and so we need to finish the function.
 mov r0, -(sp) ; Backing up r0.
 clr r0
 add r3, r1 ; r1 = source address + dest address
 div #2, r0  ; r0 will hold the address of the eaten cell in case of eat.
 mov r0, -(sp) ; Backing up the address of the eaten cell.
 ; Now we have the potenitally eaten cell address. we need to check if
 ; that eaten cell address is a multiply of 2.
 clr r0
 mov (sp), r1 ; r1 = eaten cell address.
 div #2, r0 ; r1 will hold the remainer.
 cmp r1, #0 ;
 bne .+10 ; if the remainer is not zero there was no eat. goto restore registers.
 ; If we got here then the remainer is zero. it means that there was an
 ; eat and we need to put 0 in the eaten place.
 ; Notice that the eaten cell address is at sp.
 mov #0, @(sp)
; Method is done. Restoring registers.
tst (sp)+ ; popping the eaten cell address (no longer needed).
mov (sp)+, r0 ; Restoring value of r0.
mov (sp)+, r3 ; Restoring value of r3.
mov (sp)+, r1 ; Restoring value of r1.
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                PrintStr
;-------------------------------------------------------------------------------
; This method will print a string. If '\r' is found at the end of the
; string a new line will be printed.
;
; Input:
; String adress - will be stored at 2(sp).

printStr:
cmpb #'\0, @2(sp) ; Check if reached end of string.
beq sof
cmpb #'\r, @2(sp) ;Check if reached end of string and needs to print a new line.
beq newline
movb @2(sp), @#tpb ;Print char.
inc 2(sp) ; Move to the next char.
tstb @#tps
bpl .-4  ;Busy wait, wait till end of print.
br printStr
newline:
movb #'\r, @#tpb ;Prints carrige return.
tstb @#tps
bpl .-4  ;Busy wait, wait till end of print.
movb #'\n, @#tpb ; Prints a new line.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
sof:
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printdol
;-------------------------------------------------------------------------------
; This method will print '$'.
printdol:
mov #dollar, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printHmn
;-------------------------------------------------------------------------------
; This method will print 'Human '.
printHmn:
mov #hmn, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printPC
;-------------------------------------------------------------------------------
; This method will print 'Computer '.
printPC:
mov #computer, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printSPM
;-------------------------------------------------------------------------------
; This method will print ' seconds per move '.
printSPM:
mov #secpermov, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;-------------------------------------------------------------------------------
;                                asciConv
;-------------------------------------------------------------------------------
; This method will convert decimal time to a string and save the ascii values
; of each digit starting from the end of #timelstr. Starting from the end is
; made in order to print the digits in the correct order.

;Input:
;Time decimal value - will be at 2 sp.
;Output:
;Pointer to time left string to print - will be at 4 sp.
asciConv:
mov r0, -(sp) ; Backing up r0.
mov r1, -(sp) ; Backing up r1.
mov r2, -(sp) ; Backing up r2.
clr r0
mov #timelstr, r2
add #7, r2 ; r2 will point to (end of timelstr)-1. The last char will be '0'.
mov 8.(sp), r1 ; Moving time decimal value to r1
keepdiv:
div #10., r0 ; Dividing the number by 10, the remainder will be at r1.
add #60, r1 ; converting the digit to ascii.
movb r1, -(r2) ;r2 will point one byte backwards in #timelstr and the converted digit will be put there.
tst r0 ; Checking if we still have more digits.
beq endconv ; If r0 == 0 stop dividing.
mov r0, r1 ; Move the quotient to r1.
clr r0
br keepdiv ; Keep on dividing.
endconv:
mov r2, 10.(sp) ; Move the pointer to the converted number to the place for output.
mov (sp)+, r2 ; Restoring value of r2.
mov (sp)+, r1 ; Restoring value of r1.
mov (sp)+, r0 ; Restoring value of r0.
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;-------------------------------------------------------------------------------
;                                printBPI
;-------------------------------------------------------------------------------
; This method will print "Black player is " .
printBPI:
mov #Bplyris, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printWPI
;-------------------------------------------------------------------------------
; This method will print "White player is " .
printWPI:
mov #Wplyris, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printBPT
;-------------------------------------------------------------------------------
; This method will print black player time.
printBPT:
mov #bTimeStr, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printWHT
;-------------------------------------------------------------------------------
; This method will print "White ".
printWHT:
mov #Wht, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printBLK
;-------------------------------------------------------------------------------
; This method will print "Black ".
printBLK:
mov #Blk, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printWPT
;-------------------------------------------------------------------------------
; This method will print white player time.
printWPT:
mov #wTimeStr, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printNL
;-------------------------------------------------------------------------------
; This method will print a new line.
printNL:
mov #nlfeed, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printMT
;-------------------------------------------------------------------------------
; This method will print 'move took '.
printMT:
mov #movStr, -(sp) ; Prints 'move '.
jsr pc, printStr
tst (sp)+
mov #tookStr, -(sp) ; Prints 'took '.
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printBL
;-------------------------------------------------------------------------------
; This method will print "Board layout ".
printBL:
mov #boardlay, -(sp)
jsr pc, printStr
tst (sp)+
jsr pc, printNL ; Printing new line
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                chgTurn
;-------------------------------------------------------------------------------
; This method will change turn to the other player's turn.
chgTurn:
; Changing turn
mov r0, -(sp) ; Backing up r0.
mov #3, r0
sub turn, r0 ; r0 = 3 - turn = other player's turn.
mov r0, turn ; Set turn to the next player's turn.
mov (sp)+, r0 ; Restoring value of r0.
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printWCP
;-------------------------------------------------------------------------------
; This method will print: 'Current Player: White Computer', or 'Current Player:
; White Human' by checking if the player is a human or a computer and printing
; the correct string.
printWCP:
mov #CPStr, -(sp)
jsr pc, printStr ; Prints 'Current Player : '
tst (sp)+
mov #Wht, -(sp)
jsr pc, printStr ; Prints 'White '.
tst (sp)+
cmp #1, wPlayer ; Checks if the player is a human or a computer.
beq whitpl
; White Player is computer
mov #computer, -(sp)
jsr pc, printStr ; Prints 'Computer '.
tst (sp)+
jmp endWCP
whitpl:
; White player is Human
mov #hmn, -(sp)
jsr pc, printStr ; Prints 'Human '.
tst (sp)+
endWCP:
jsr pc, printNL ; Printing new line
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printWP
;-------------------------------------------------------------------------------
; This method will convert WP to a string and print it.
printWP:
mov r0, -(sp) ;Backing up r0.
mov r1, -(sp) ;Backing up r1.
clr r0
mov WinParam, r1
tst WinParam
bpl positWP
;Negative WP, print '-' and multiply by -1.
mul #-1., r1 ; Converting WP to a positive number.
movb #'-, @#tpb ; Printing '-' becuase the WP was negative.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
positWP:
; Positive WP
div #10., r0 ; Dividing WP by 10 to get decimal digit.
add #60, r1 ; Converts the digit to ascii.
tst r0 ; Checks if WP had 1 digit.
beq endWP ; WP was less than 10 (decimal) and had 1 digit.
add #60, r0 ; WP had 2 digits, converts the left digit to ascii.
movb r0, @#tpb ; Printing first digit.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
endWP:
movb r1, @#tpb ; Printing second digit.
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
mov (sp)+, r1 ; Restores r1's value.
mov (sp)+, r0 ; Restores r0's value.
jsr pc, printNL ; Prints a new line.
rts pc


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printBCP
;-------------------------------------------------------------------------------
; This method will print: 'Current Player: Black Computer', or 'Current Player:
; Black Human' by checking if the player is a human or a computer and printing
; the correct string.
printBCP:
mov #CPStr, -(sp)
jsr pc, printStr ; Prints 'Current Player : '
tst (sp)+
mov #Blk, -(sp)
jsr pc, printStr ; Prints 'Black '.
tst (sp)+
cmp #1, bPlayer ; Checks if the player is a human or a computer.
beq blkpl
; Black Player is computer
mov #computer, -(sp)
jsr pc, printStr ; Prints 'Computer '.
tst (sp)+
jmp endBCP
blkpl:
; Black player is Human
mov #hmn, -(sp)
jsr pc, printStr ; Prints 'Human '.
tst (sp)+
endBCP:
jsr pc, printNL ; Printing new line
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;-------------------------------------------------------------------------------
;                                printWin
;-------------------------------------------------------------------------------
; This method checks #WinParam and prints the correct winning message.
printWin:
tst WinParam
beq isTie ; If WinParam is 0 branch to isTie.
tst WinParam
bgt curWin ; If win param > 0 , the current player won.
;Current player didn't win.
cmp turn, #1
beq Blackwin ; If turn is 1 (white player's turn), black player won.
br Whitewin ; If turn is 0 (black player's turn), white player won.
curWin:
; Current player won.
cmp turn, #1
beq Whitewin ; If turn is 1 white player won.
Blackwin:
;Black player won.
jsr pc, printBLK ; Prints 'Black '.
mov #playerWin, -(sp)
jsr pc, printStr ; Prints 'player wins!' ;
tst (sp)+
rts pc
Whitewin:
;White player won.
jsr pc, printWHT ; Prints 'White '.
mov #playerWin, -(sp)
jsr pc, printStr ; Prints 'player wins!' ;
tst (sp)+
rts pc
isTie:
mov #itsATie, -(sp)
jsr pc, printStr ; Prints 'It's a tie! Game over.' ;
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                RstBWStr
;-------------------------------------------------------------------------------
; This method resets the values of bTimeStr and wTimeStr, by putting 0 in each
; word in the strings.
RstBWStr:

mov r0, -(sp) ; Backing up r0
mov #25., r0 ; r0 contains the number of words to be reseted in each string.
mov #bTimeStr, bTimePtr ;bTimePtr will be used to point #bTimeStr.
mov #wTimeStr, wTimePtr ;wTimePtr will be used to point #wTimeStr.
loopRst:
;Puts '0' in all words in #bTimeStr, #wTimeStr.
mov #0, @bTimePtr
add #2, bTimePtr
mov #0, @wTimePtr
add #2, wTimePtr
sub #1, r0
cmp r0, #0 ;Check if reached end of the strings.
bne loopRst
mov #bTimeStr, bTimePtr ;Sets bTimePtr to point to the start of #bTimeStr.
mov #wTimeStr, wTimePtr ;Sets wTimePtr to point to the start of #wTimeStr.
mov (sp)+, r0 ; Restoring r0
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printB
;-------------------------------------------------------------------------------
; This method will print the playing board.
printB:
jsr pc, printNL ; Printing new line
jsr pc, printNL ; Printing new line
jsr pc, printNL ; Printing new line
jsr pc, printBL ; Printing 'Board layout:\r'
mov r0, -(sp) ; Backing up r0.
mov r1, -(sp) ; Backing up r1.
mov r2, -(sp) ; Backing up r2.
mov #8., r2 ; r2 will be initialized with 8 (number of words to print per row).
mov #Board, r1
add #128., r1 ; r1 will contain the adress of #Board+2.
mov #Board, r0
Ploop:
cmp r0, r1 ; Check if reached end of #Board+2.
beq endP ; If reached #Board+2, board printed, branch to end print.
tst r2
bne conP ; If r2>0 we are still at the same row.
mov #8., r2 ; If r2 = 0, set it back to 8 (number of words to print per row).
jsr pc, printNL ; Printing new line
conP:
cmp (r0), #0 ;Check if we need to print _.
beq print_
cmp (r0), #1 ;Check if we need to print W.
beq printWH
tst (r0) ; Move to the next word.
movb #'B, @#tpb
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
add #2, r0 ; Move to the next word in #Board.
dec r2 ; Reduce number of words to print by 1 .
br Ploop
printWH:
movb #'W, @#tpb
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
add #2, r0 ; Move to the next word in #Board.
dec r2 ; Reduce number of words to print by 1 .
br Ploop
print_:
movb #'_, @#tpb
tstb @#tps
bpl .-4 ;Busy wait, wait till end of print.
add #2, r0 ; Move to the next word in #Board.
dec r2 ; Reduce number of words to print by 1
br Ploop
endP:
;Board printed.
jsr pc, printNL ; Printing new line
jsr pc, printNL ; Printing new line
mov (sp)+, r2 ; Restore r2's value.
mov (sp)+, r1 ; Restore r1's value.
mov (sp)+, r0 ; Restore r0's value.
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                initBoard
;-------------------------------------------------------------------------------
;This method will initialize the playing board.
initBoard:
mov r0, -(sp) ; Backing up r0.
mov r1, -(sp) ; Backing up r1.
mov r2, -(sp) ; Backing up r2.
mov #Board, r1
add #128., r1 ; r1 will contain the adress of #Board+2.
mov #Board, r0 ; r0 will hold #Board adress.
mov #NewBoard, r2 ; r2 will hold #NewBoard adress (new board contains a board of a new game).
Cpyloop:
cmp r0, r1 ; Check if reached end of #Board+2.
beq endCpy ; If reached #Board+2, board printed, branch to end print.
mov (r2)+, (r0)+ ;Copy a word from new board to the playing board and move to the next word.
br Cpyloop
endCpy:
;Board copying ended.
mov (sp)+, r2 ; Restore r2's value.
mov (sp)+, r1 ; Restore r1's value.
mov (sp)+, r0 ; Restore r0's value.
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                chkwins
;-------------------------------------------------------------------------------
; This method checks if someone won and prints the correct winning message.
chkwins:
mov r0, -(sp) ; Backing up r0
mov #Board, -(sp)
mov turn, -(sp) ; Moves the current player's turn to the stack.
tst -(sp) ; Place for output.
jsr pc, checkWin
mov (sp)+, r0 ; r0 contains the output of checkwin.
add #4, sp ; Pops turn and #Board.
cmp #1, r0
beq CurPW ; if r0 == 0 , current Player won.
cmp #2, r0
beq tiegover ; Tie, Game Over.
; Current player didn't win. Lets check win for the other player.
mov #3, r0
sub turn, r0 ; r0 = 3 - turn = other player's turn.
mov #Board, -(sp)
mov r0, -(sp) ; Backing up r0
tst -(sp) ; Place for output.
jsr pc, checkWin
mov (sp)+, r0 ; r0 contains the output of checkwin.
add #4, sp ; Pops turn and #Board.
cmp #-1., r0 ; If r0 == -1 , other player didn't win, no winners.
beq NoWinner
cmp #2, r0
beq tiegover ; Tie, Game Over
; Opposite player win
cmp turn, #1
beq .+14 ; Black player wins
br WPW

CurPW:
;Current player won.
cmp turn, #1
beq WPW ; White Player Win
; Black Player Win
mov #0, gameOn
jsr pc, printBLK
mov #playerWin, -(sp)
jsr pc, printStr ; Prints 'player wins!'.
tst (sp)+
br NoWinner
WPW:
mov #0, gameOn ; Stopping the game
jsr pc, printWHT
mov #playerWin, -(sp)
jsr pc, printStr ; Prints 'player wins!'.
tst (sp)+
NoWinner:
jsr pc, printNL
mov (sp)+, r0 ; Restoring r0
rts pc

tiegover:
mov #0, gameOn ; Stopping the game
mov #0, @#lcs ; Stopping clock
mov #itsATie, -(sp)
jsr pc, printStr ; Prints 'It's a tie! Game over.'.
tst (sp)+
br NoWinner
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;-------------------------------------------------------------------------------
;                                 getMaxWP:
;-------------------------------------------------------------------------------
; This function makes first preperations and calls the reccursive function.
; Inputs:
;   1. #SrcPos - Label to write the source position of the piece should move.
;   2. #DstPos - Label to write the destenation position of the piece should move.
;   3. #WinParam - Label to write the winning parameter.
; A label of the board, number of steps (how deep to check) and the player to
; check will also be inputs in a common area.
; Outputs:
; The outputs will be written to the given labels (inputs).
;-------------------------------------------------------------------------------
getMaxWP:
; Preparing the stack for the first call.
mov #0, -(sp) ; Allocating place source position in stack.
mov #0, -(sp) ; Allocating place destenation position in stack.
mov #-100., -(sp) ; Allocating place for WP in stack.
mov #1, -(sp) ;  Allocating place for minOrMax of the first player.
mov turn, -(sp) ; Pushing the player we check to the stack.
mov Steps, -(sp) ; Pushing number of steps to stack.
; Calling the recursive function.
jsr pc, getWPRec
tst gameOn
beq CpuTup ; If game on is 0 (game stopped) don't update WinParam, SrcPos and DstPos.
tst TIMOUT
bne CpuTup ; If time out is 1 (Turn time ended) don't update WinParam, SrcPos and DstPos.
; Computer player still has time.
; Recursive function finished
; Popping unnecessary data from stack and writing output to given labels:
add #6, sp ; Popping unnecessary data from stack.
mov (sp)+, @6.(sp) ; Writing the best wp to WP label.
; SrcPos and DstPos returned as address of the board.
mov (sp)+, @6.(sp) ; Writing adress to DstPos
mov (sp)+, @6.(sp) ; Writing adress to SrcPos
add #2, Steps ; There is till time for the move, increase steps by 2 and start over.
jmp getMaxWP
CpuTup:
;Time is up for computer's turn, pop stack and return.
add #12., sp
rts pc ; Returning to main.

;-------------------------------------------------------------------------------
;                                 getWPRec:
;-------------------------------------------------------------------------------
; This function is the recursive function. It calculates the best next move of a
; given player in a given board.
; Inputs:
;   1. Player to check - will be in a common area.
;   2. Steps - number of steps left to check.
;   3.
;-------------------------------------------------------------------------------
; This is the reccursive function.
getWPRec:
; ----- STOP TERMS -----
tst gameOn ; If game on is 0, game stopped quit recursion.
bne .+4
rts pc
tst TIMOUT ; If time out is 1, time of the turn is over, quit recursion.
beq .+4
rts pc
; Preparing to call for checkWin with the last player to make a move:
mov #Board, -(sp) ; Moving board adress to stack.
; Pushing the last player to make a move to stack.
; The current player has changed before calling the rec function, therefore
; we switch to the other player (black + white - current_player):
mov #3, -(sp)
sub 8.(sp), (sp)
mov #0, -(sp) ; Allocating space for output of checkWin.
; Checks if the last player to make a move won:
jsr pc, checkWin
cmp #1, (sp)+ ; Checking the output and pops it from stack.
beq whoWon ; Jumps if he won.

; Last player didn't win. Now we'll check if the current player won:
mov 8.(sp), (sp) ; Moving current player to the top of the stack.
mov #0, -(sp) ; Allocating space for output of checkWin.
jsr pc, checkWin
cmp #1, (sp)+ ; Checking the output and pops it from stack.
beq whoWon ; Jumps if he won.

; If we got here no one won.
add #4, sp ; Pop the other player and board from the stack.
tst 2(sp) ; Check if the current number of steps is 0.
bne jchkMov ; Jumps if (steps > 0)

; If we got here steps is 0.
mov #Board, -(sp) ; Moving board adress to stack.
mov turn, -(sp) ; Moving the player we check to the top of the stack.
jsr pc, calcWP ; Output will be at r4.
add #4, sp ; Popping the no longer needed inputs (board and player).
mov r4, 8.(sp) ; Copying output from r4 to caller's wp.
rts pc

jchkMov:
; Checking if the current player has legal moves to make:
mov 4(sp), -(sp) ; Moving current player to the top of the stack.
mov #0, -(sp) ; Allocating a place for output.
jsr pc, hasMove
mov (sp)+, (sp) ; Writing the output of hasMove instead of current player (override).
tst (sp)+  ; Checks if number of legal moves of current player is 0 and pops it.
bne chkMoves ; Jumps if he has moves to make.
; If we got here the current player has no legal moves and we need to skip his turn.
; Preparing to call next iteration:
mov #0, -(sp) ; Allocating space for SrcPos.
mov #0, -(sp) ; Allocating space for DstPos.
cmp 10.(sp), #1 ; Checks what the caller function (father) was looking for.
bne putMax ; Jumps if the father was looking for minimum.
; Father was looking for maximum. Now we should put minimum:
mov #100., -(sp) ; Pushing wp. WP = MAX_VALUE
mov #-1., -(sp) ; Pushing -1. This means that we are looking for minimum now.
jmp cont ; Done changing max->min.

putMax:
; Father was looking for minimum. Now we should put maximum:
mov #-100., -(sp) ; Pushing wp. WP = MIN_VALUE
mov #1., -(sp) ; Pushing -1. This means that we are looking for maximum now.

cont:
; Continues the preperations.
; Switch players:
mov #3., -(sp)
sub 14.(sp), (sp)
; Reducing steps by 1:
mov 12.(sp), -(sp)
sub #1., (sp)
jsr pc, getWPRec
; Checking if it is the first move. If yes, we will handle it seperatly.
add #1, (sp) ; Adding 1 to current steps because we reduced it by 1 before.
cmp (sp), Steps ; Checking if current steps is the global steps (aka first move).
beq firstMov ; if current steps = global steps - go to firstMov to handle it.
sub #1, (sp) ; Restoring steps to what it was before the cmp.

; Checking the returned values and updating if needed:
cmp #1., 18.(sp) ; Checks what the caller function (father) was looking for.
beq wasMax ; Jumps if the father was looking for maximum.
; Father was looking for minimum. Checks if we need to update WP to the new WP.
cmp 6.(sp), 20.(sp) ; Comparing WPs.
bgt noUp ; Jumps if we don't need to update.
; If we got here we need to update:
mov 6.(sp), 20.(sp) ; Updating father's wp.
mov 8.(sp), 22.(sp) ; Updating father's DstPos.
mov 10.(sp), 24.(sp) ; Updating father's SrcPos.
add #12., sp ; Popping unnecessary data from stack.
rts pc

wasMax:
; Father was looking for maximum. Checks if we need to update WP to the new WP.
cmp 6.(sp), 20.(sp) ; Comparing WPs.
ble noUp ; Jumps if we don't need to update.
; If we got here we need to update:
mov 6.(sp), 20.(sp) ; Updating father's wp.
mov 8.(sp), 22.(sp) ; Updating father's DstPos.
mov 10.(sp), 24.(sp) ; Updating father's SrcPos.
add #12., sp ; Popping unnecessary data from stack.
rts pc

firstMov:
; If we got here then in the first move the player we check cannot move. therefore
; we need to find any piece of his and update the src and dst to the location of
; that piece.
sub #1, (sp) ; Restoring steps to what it was before the cmp after jsr.
mov #Board, -(sp) ; will be used to scan for a piece.
fPiece:
cmp @(sp), turn
beq pieceF ; Piece found - go to update src and dst.
add #2, (sp) ; Continue checking in the next cell.
br fPiece
pieceF:
mov 8.(sp), 22.(sp) ; Updating father's wp.
mov (sp), 24.(sp) ; Updating father's DstPos.
mov (sp)+, 24.(sp) ; Updating father's SrcPos.
noUp:
; If we got here we do not need to update.
add #12., sp ; Popping unnecessary data from stack.
rts pc

whoWon:
cmp 6(sp), Steps
bne goOn
; This code will update Src and Dst in situations of instant win, meaning the
; given board is already in a state of win.
mov #Board, -(sp)
fwinPiece: ; finding any piece of the winner.(reminder: this is an instant win)
cmp @(sp), turn
beq pFound ; Piece Found
add #2, (sp)
br fwinPiece
pFound:
mov (sp), 16.(sp) ; Updating father's DstPos.
mov (sp)+, 16.(sp) ; Updating father's SrcPos.


goOn:
; Checks who won.
cmp (sp)+, turn ; Check if the current player is the one we check.
bne playerLos ; Jumps if the winner is not who we check.
; The winner is the player we check. Updating WP to 20:
mov #20, 10.(sp) ; WP = 20.
tst (sp)+ ; Popping the no longer needed board from stack.
rts pc
playerLos:
;The winner is not the player we check. Updating WP to -20:
mov #-20, 10.(sp) ; WP = -20.
tst (sp)+ ; Popping the no longer needed board from stack.
rts pc
; --- END OF STOP TERMS ---

; r0 - Current row index.
; r1 - Current column index.
chkMoves:
clr r0 ; Sets r0 to 0.
clr r1 ; Sets r1 to 0.
cmp 4(sp), #1 ; Checking if the current color is white.
bne jBlack ; If the color is not white, branch to Black.
jmp White ; If the color is white, branch to White.

jBlack:
  jmp Black

; This method will check legal moves of all white pieces and calls the reccursive
; function each time a legal move is found.
; r2 - Will store the current checked cell address.
; r3 - temporary row index (will be used once for another calculation).
; r5 - temporary column index (will be used once for another calculation).
White:
mov r0, r3  ; Putting index of the current row in r3.
mov r1, r5  ; Putting index of the current column in r5.
mov #Board, r2 ; Putting board array starting index in r2.
mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bytes).
mul #2, r5 ; Multiplying the number of column by 2 (decimal) (width of each column in bytes).
add r3, r2 ; Adding the number of bytes needed in order to point to the beginning of a row.
add r5, r2 ; Adding the number of bytes needed in order to point a cell in a row.
; r2 will now contain the address of the current cell.
cmp (r2), #1 ; Checking if the current piece is white.
bne NextCell ; If the color of the current piece is not white skip to the next cell.
mov r0, r3 ; Setting r3 to the current row index (after changing it earlier).
sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt NextCell ; If row index is less than 0, cannot move at all, skip to the next cell.
mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
add #1, r5 ; Increasing column index by 1.
cmp r5, #7
bgt LeftW ; If column index is bigger than 7, the current piece cannot move right, check legal moves to the left.
cmp -14.(r2), #1 ; Checking if the upper right piece is white.
beq LeftW ; If the upper right piece is white, cannot go there, check legal moves to the left.
cmp -14.(r2), #2 ; Checking if the upper right piece is black.
beq EatRW ; If the upper right piece is black, check if the white piece can eat it.

; --- WHITE CAN MOVE RIGHT ---
; Current white piece can move to the right.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
sub #14., (sp)
; No eaten piece. Inserting 0:
mov #0, -(sp)
; Makes the move:
jsr pc, WhiteMov
add #4., sp ; Popping unnecessary data from stack.
jmp LeftW ; Go to check if this piece can also move to the left.

; --- WHITE EAT RIGHT ---
; Checks if white piece can eat to the right.
EatRW:
sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt LeftW ; If r3 is less than 0, cannot eat (out of bounds). Check legal moves to the left.
add #1, r5 ;Increasing column index by 1.
cmp r5, #7
bgt LeftW ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the left.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, we need to check if it is empty.
cmp -28.(r2), #0 ; Checking if the cell is empty.
bne LeftW ; If the cell is not empty, cannot eat. Check legal moves to the left.

; --- WHITE CAN EAT RIGHT ---
; Current white piece can eat to the right.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
sub #28., (sp)
; Inserting location of eaten piece.
mov r2, -(sp)
sub #14., (sp)
; Makes the move:
jsr pc, WhiteMov
add #4., sp ; Popping unnecessary data from stack.
jmp LeftW ; Go to check if this piece can also move to the left.

; --- WHITE MOVE LEFT ---
; Checks if white piece can move left.
LeftW:
mov r0, r3 ; Putting index of the current row in r3.
sub #1, r3 ; Reducing row index by 1.
mov r1, r5 ; Putting index of the current column in r5.
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt NextCell ; If column index is less than 0, cannot move right, skip to the next cell.
cmp -18.(r2), #1 ; Checking if the upper left piece is white.
beq NextCell ; If the upper left piece is white, cannot move there, skip to the next cell.
cmp -18.(r2), #2 ; Checking if the upper left piece is black.
beq EatLW ; If the upper left piece is black, Check if the white piece can eat it.

; --- WHITE CAN MOVE LEFT ---
; Current white piece can move to the left.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
sub #18., (sp)
; No eat. Inserting 0:
mov #0., -(sp)
; Makes the move:
jsr pc, WhiteMov
add #4., sp
jmp NextCell ; Current white piece cannot move anymore. Go to check next cell.

; --- WHITE EAT LEFT ---
; Checks if white piece can eat to the left.
EatLW:
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt NextCell ; If column index is less than 0, cannot eat, skip to the next cell.
sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt NextCell ; If r3 is less than 0, cannot eat (out of bounds). Skip to the next cell.
;If we got here, the cell which the current white piece should be
;placed in after eating is in the board bounds, Check if it is empty.
cmp -36.(r2), #0 ; Checking if the cell is empty.
bne NextCell ;If the cell is not empty, cannot eat. Skip to the next cell.

; --- WHITE CAN EAT LEFT ---
; Current white piece can eat to the left.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
sub #36., (sp)
; Inserting location of eaten piece:
mov r2, -(sp)
sub #18., (sp)
; Makes the move:
jsr pc, WhiteMov
add #4., sp ; Popping unnecessary data from stack.
jmp NextCell ; Current white piece cannot move anymore. Go to check next cell.

End: ;If we got here we checked all the cells of the array.
rts pc

; This method will skip to the next cell by adding 1 to column index. If column
; index is bigger than 7 sets it to 0 and adds 1 to row index.
; r0 - Current row index.
; r1 - Current column index.
NextCell:
add #1, r1 ; Increasing column index by 1.
cmp r1, #8 ; Checking if reached the end of the row.
blt InRange ; Branch to InRange if the index of column is legal.
clr r1 ; If we got here index of column reached the end of row. Sets it to 0.
add #1, r0 ; Go to the next row.
cmp r0, #7
bgt End ; If index of row is bigger than 7 we reached the end of the board.

;Continues to the next cell once its indexes are valid.
InRange:
cmp 4(sp), #1
bne Black
jmp White

jNxtCell:
  jmp NextCell

; This method will check legal moves of all black pieces and calls the reccursive
; function each time a legal move is found.
; r2 - Will store the current checked cell address.
; r3 - temporary row index (will be used once for another calculation).
; r5 - temporary column index (will be used once for another calculation).
Black:
mov r0, r3  ; Putting index of the current row in r3.
mov r1, r5  ; Putting index of the current column in r5.
mov #Board, r2 ; Putting board array starting index in r2.
mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bytes).
mul #2, r5 ; Multiplying the number of column by 2 (decimal) (width of each column in bytes).
add r3, r2 ;Adding the number of bytes needed in order to point to the beginning of a row.
add r5, r2 ; Adding the number of bytes needed in order to point a cell in a row.
; r2 will now contain the address of the current cell.
cmp (r2), #2 ; Checking if the current piece is black.
bne NextCell ; If the color of the current piece is not black skip to the next cell.
mov r0, r3 ; Putting index of the current row in r3.
add #1, r3 ; Increasing row index by 1.
cmp r3, #7
bgt NextCell ; If row index is bigger than 7, cannot move at all, skip to the next cell.
mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
add #1, r5 ; Increasing column index by 1.
cmp r5, #7
bgt RightB ; If column index is bigger than 7, the current piece cannot move left, Check legal moves to the right.
cmp 18.(r2), #2 ; Checking if the lower right piece is black.
beq RightB ; If the lower left piece is black, cannot go there, Check legal moves to the right.
cmp 18.(r2), #1 ; Checking if the lower right piece is black.
beq EatLB ; If the lower right piece is white, check if the black piece can eat it.


; --- BLACK CAN MOVE LEFT ---
; Current black piece can move to the left.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
add #18., (sp)
; No eaten piece. Inserting 0:
mov #0, -(sp)
; Makes the move:
jsr pc, BlackMov
add #4., sp ; Popping unnecessary data from stack.
jmp RightB ; Go to check if current black piece can move to the right.

; --- BLACK EAT LEFT ---
; Checks if black piece can eat to the left.
EatLB:
add #1, r3 ; Increasing row index by 1.
cmp r3, #7 ; If r3 is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
bgt RightB
add #1, r5 ;Increasing column index by 1.
cmp r5, #7
bgt RightB ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
;If we got here, the cell which the current black piece should be placed after eating is in the board bounds, we need to check if it is empty.
cmp 36.(r2), #0 ; Checking if the cell is empty.
bne RightB ; If the cell is not empty, cannot eat. Check legal moves to the right.

; --- BLACK CAN EAT LEFT ---
; Current black piece can move to the left.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
add #36., (sp)
; Inserting location of eaten piece:
mov r2, -(sp)
add #18., (sp)
; Makes the move:
jsr pc, BlackMov
add #4., sp ; Popping unnecessary data from stack.
jmp RightB

; --- BLACK MOVE RIGHT ---
; Checking if black piece can move right.
RightB:
mov r0, r3 ; Putting index of the current row in r3.
add #1, r3 ; Increasing row index by 1.
mov r1, r5 ; Putting index of the current column in r5.
sub #1, r5 ; Decreasing column index by 1.
cmp r5, #0
blt NextCell ; If column index is less than 0, cannot move right, skip to the next cell.
cmp 14.(r2), #2 ; Checking if the lower left piece is black.
beq NextCell ; If the lower left piece is white, cannot move there, skip to the next cell.
cmp 14.(r2), #1 ; Checking if the lower left piece is white.
beq EatRB ; If the lower left piece is white, check if the black piece can eat it.

; --- BLACK CAN MOVE RIGHT ---
; Current black piece can move to the right.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
add #14., (sp)
; No eaten piece. Inserting 0:
mov #0, -(sp)
; Makes the move:
jsr pc, BlackMov
add #4., sp ; Popping unnecessary data from stack.
jmp NextCell ; Current black piece cannot move anymore. Go to next cell.

EatRB:
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt NextCell ; If column index is less than 0, cannot eat, skip to the next cell.
add #1, r3 ; Increasing row index by 1.
cmp r3, #7
bgt NextCell ; If r3 is bigger than 7, cannot eat (out of bounds). Skip to the next cell.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
cmp 28.(r2), #0 ; Checking if the cell is empty.
bne jNxtCell ;If the cell is not empty, cannot eat. Skip to the next cell.

; --- BLACK CAN EAT RIGHT ---
; Current black piece can eat to the right.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
add #28., (sp)
; Inserting location of eaten piece:
mov r2, -(sp)
add #14., (sp)
; Makes the move:
jsr pc, BlackMov
add #4., sp ; Popping unnecessary data from stack.
jmp NextCell ; Current black piece cannot move anymore. Go to next cell.


; This method checks if a given board is in a winning state for the given player.
; Input:
; 1. A number of player to check - will be stored in 4(sp).
; 2. A label of the beginning of the board - will be stored in 6(sp).
; Output:
; -1 if the current player didn't win, 1 if the current player wins - will be stored in 2(sp).
checkWin:
tst -(sp) ; Allocating place for number of white pieces (output of countWB).
tst -(sp) ; Allocating place for number of black pieces (output of countWB).
mov 12(sp), -(sp) ; Copying board adress to the top of the stack.
jsr pc, countWB ; Counting number of pieces from each color and puts it in stack.
tst (sp)+ ; Pop board adress.
cmp 10(sp), #1 ; Check if the current player is white.
bne checkb ; Branch to checkb if the current player is black.
tst (sp) ; Current player is white, checks the number of black pieces.
beq currWin ; If the number of black pieces is 0 white player wins.
tst 2(sp) ; Checks the number of white pieces.
beq noWin ; Current player is white and the number of white pieces is 0, white player loses.
br not0 ; Both player's number of pieces is not 0.

checkb: ; The current player is black.
tst 2(sp) ; Checks if the number of white pieces is 0.
beq currWin ; Black player wins.
tst (sp) ; Checks if the number of black pieces is 0.
beq noWin ; Current player is black and the number of black pieces is 0.

not0: ; We get here if the number of both player's pieces is not 0.
mov #1, -(sp) ; Moving number of white player to check number of moves for him.
mov #0, -(sp) ; Allocating place for number of moves and setting it to 0.
; Checking if there is legal moves for the given player.
jsr pc, hasMove ; Number of legal moves for white player will be at the top of the stack.
tst (sp) ; Checks if white player has legal moves to make.
bne hasMoves ; There are still moves to make.
mov #2, 2(sp) ; Moving number of black player to check number of moves for him.
jsr pc, hasMove ; Number of legal moves for black player will be at the top of the stack.
tst (sp) ; Checks if both players has legal moves to make.
bne hasMoves ; One of the players still has moves to make.
tst (sp)+ ; Pops number of player's moves.
tst (sp)+ ; Pops player number.
cmp (sp), 2(sp)
beq tieGOver ; Tie, game over.
cmp #1, 10(sp) ; Checks if the player is the white player.
bne blackChk ; The player is the black player.
cmp 2(sp), (sp) ; Checks if number of white pieces is bigger than number of black pieces.
bgt currWin ; If the number of white pieces is bigger, white player wins.
br noWin ; If we got here the number of white pieces is not bigger.
blackChk: ; The current player color is black.
cmp (sp), 2(sp) ; Checks if number of black pieces is bigger than number of white pieces.
bgt currWin ; Black player wins.
br noWin ; Black player lost.

tieGOver:
tst (sp)+ ; Pop number of black pieces.
tst (sp)+ ; Pop number of white pieces.
mov #2, 2(sp)
rts pc

currWin: ; The current player wins.
tst (sp)+ ; Pop number of black pieces.
tst (sp)+ ; Pop number of white pieces.
mov #1, 2(sp) ; The return value will be 1.
rts pc

hasMoves: ; One of the players still has legal moves.
tst (sp)+ ; Pops number of moves.
tst (sp)+ ; Pops the number of player.
noWin: ; The current player is not winning.
tst (sp)+ ; Pop number of black pieces.
tst (sp)+ ; Pop number of white pieces.
mov #-1., 2(sp)
rts pc
; END OF checkWin

; This method will calculate the winning parameter of a given board.
; Input:
; 1. Label of the current board status - will be stored at 4(sp).
; 2. Current player's turn (1-white,2-black) - will be stored at 2(sp).
; Output:
; Winning parameter - will be stored at R4.
calcWP:
mov 0, -(sp) ; Leaving blank space for output of countWB.
mov 0, -(sp) ; Leaving blank space for output of countWB.
mov 8(sp), -(sp) ; Giving the label of the board as input.
jsr pc, countWB ; Counting number of pieces from each color.
add #2, sp ; Popping the no longer needed board label from stack.
cmp 6(sp), #2
beq WPforW ; if current player (input) is black - go to WPforW
; If we got here then the current player is black. It means that
; the last player to move was white.
mov 2(sp), r4 ; r4 = number of white vessels.
sub (sp), r4 ; r4 = r4 - number of black vessels.
br endCalWP ; Jumping to the end of the method.
WPforW:
; If we got here current player is white. It means that the
; last player to move was black.
mov (sp), r4 ; r4 = number of black vessels.
sub 2(sp), r4 ; r4 = r4 - number of white players.
br endCalWP ; Jumping to the end of the method.
endCalWP:
add #4, sp ; popping 2 items from stack (counters of W&B pieces)
rts pc
; END OF calcWP

; ------------------------- HELPING FUNCTIONS -------------------------
; 1. WhiteMov - Making a move for white piece and calls the recursive function.
; 2. Blackmov - Making a move for black piece and calls the recursive function.
; 3. countWB - Counting number of pieces from each color.
; 4. hasMove - Counting the legal moves of a given player in a given board.
;----------------------------------------------------------------------

; This method will do the moving of a white piece and calls the reccursive function.
; Input:
; 1. Address of piece to move.
; 2. Address of eaten piece. If it is not an eat the value will be 0.
WhiteMov:
; Making the move of the white player:
mov #1, @4.(sp) ; Moving white piece to the new place.
mov #0, (r2) ; Removing white piece from the last place it was.

; Checks if there is an eat
tst 2(sp)
beq noEat

; If we got here there is an eat
mov #0, @2.(sp) ; Removing eaten piece

noEat:
; Backing up registers before calling the REC function.
mov r0, -(sp) ; Backing up r0.
mov r1, -(sp) ; Backing up r1.
mov r2, -(sp) ; Backing up r2.
mov r3, -(sp) ; Backing up r3.
mov r5, -(sp) ; Backing up r5.

; Preparing the arguments for the REC function.
mov #0, -(sp) ; Allocating source position.
mov #0, -(sp) ; Allocating destenation position.
cmp #1, 26.(sp) ; Checking if minimum or maximum was checked in the last call.
beq chngMin ; Changing maximum to minimum.

; If we got here in the next REC we will check for maximum
mov #-100., -(sp) ; Miminum was checked in the last call.
mov #1, -(sp) ; Maximum will be checked.
br changed

chngMin: ; Changing maximum to minimum.
mov #100., -(sp) ; Maximum was checked in the last call.
mov #-1., -(sp) ; Minimum will be checked.

changed: ; Changed maximum\minimum value.
mov #3, -(sp)
sub 30.(sp), (sp) ; Chaning to the other player.
mov 28.(sp), -(sp) ; Copying last number of steps.
sub #1, (sp) ; Substract 1 from number of steps.
jsr pc, getWPRec

cmp 34.(sp), #1 ; The father is looking for a maximum.
beq upMax ; Father was looking for a maximum.

; Father was looking for a minimum.
cmp 6.(sp), 36.(sp) ; Comparing wp to the wp of the father.
bgt nUpdate

; Updating minimum.
mov 6(sp), 36.(sp) ; Updating father wp to new minimum.
add #12., sp ; Popping all values besides registers backup.
mov (sp)+, r5
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0

; Restoring previous board and updating father src and dst.
; Restoring white piece previous location.
mov #1, (r2)
mov #0, @4.(sp)
; Checks if there was an eat:
tst 2(sp) ;
beq SrcDst ; No eat. We don't need to restore. go to update src and dst.
; If we got here there was an eat and we need to restore it.
mov #2., @2.(sp) ; Restoring eaten black piece.
br SrcDst

SrcDst:
mov r2, 18.(sp) ; Updating father's SrcPos.
mov 4(sp), 16.(sp) ; Updating father's DstPos.
rts pc

nSrcDst:
rts pc

upMax:
; The father is looking for maximum
cmp 6(sp), 36.(sp) ; Comparing wp to the wp of the father.
ble nUpdate ; Jumps if we do not need to update.

; We need to update to new Maximum
mov 6(sp), 36.(sp) ; Updating father wp to new maximum.
add #12., sp ; Popping all values besides registers backup.
mov (sp)+, r5
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0

; Restoring previous board and updating father src and dst.
; Restoring white piece previous location.
mov #1, (r2)
mov #0, @4.(sp)
; Checks if there was an eat:
tst 2(sp) ;
beq SrcDst ; No eat. We don't need to restore. go to update src and dst.
; If we got here there was an eat and we need to restore it.
mov #2., @2.(sp) ; Restoring eaten black piece.
br SrcDst

nUpdate:
add #12., sp ; Popping all values besides registers backup.
mov (sp)+, r5
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0
; Restoring previous board and updating father src and dst.
; Restoring white piece previous location.
mov #1, (r2)
mov #0, @4.(sp)
; Checks if there was an eat:
tst 2(sp) ;
beq nSrcDst ; No eat. We don't need to restore. No need to update src and dst.
mov #2., @2.(sp) ; Restoring eaten black piece.
br nSrcDst ; No need to update src and dst.
; END OF WhiteMov

; This method will do the moving of a black piece and calls the reccursive function.
; Input:
; 1. Address of piece to move.
; 2. Address of eaten piece. If it is not an eat the value will be 0.
BlackMov:
; Making the move of the black player.
mov #2, @4.(sp) ; Moving black piece to the new place.
mov #0, (r2) ; Removing black piece from the last place it was.

; Checks if there is an eat
tst 2(sp)
beq noEatB

; If we got here there is an eat
mov #0, @2.(sp) ; Removing eaten piece

noEatB:
; Backing up registers before calling the REC function.
mov r0, -(sp) ; Backing up r0.
mov r1, -(sp) ; Backing up r1.
mov r2, -(sp) ; Backing up r2.
mov r3, -(sp) ; Backing up r3.
mov r5, -(sp) ; Backing up r5.

; Preparing the arguments for the REC function.
mov #0, -(sp) ; Allocating source position.
mov #0, -(sp) ; Allocating destenation position.
cmp #1, 26.(sp) ; Checking if minimum or maximum was checked in the last call.
beq chngMinB ; Changing maximum to minimum.

; If we got here in the next REC we will check for maximum
mov #-100., -(sp) ; Miminum was checked in the last call.
mov #1, -(sp) ; Maximum will be checked.
br .+12

chngMinB: ; Changing maximum to minimum.
mov #100., -(sp) ; Maximum was checked in the last call.
mov #-1., -(sp) ; Minimum will be checked.

; Changed maximum\minimum value.
mov #3, -(sp)
sub 30.(sp), (sp) ; Changing to the other player.
mov 28.(sp), -(sp) ; Copying last number of steps.
sub #1, (sp) ; Substract 1 from number of steps.
jsr pc, getWPRec

cmp 34.(sp), #1 ; The father is looking for a maximum.
beq upMaxB ; Father was looking for a maximum.

; Father was looking for a minimum.
cmp 6(sp), 36.(sp) ; Comparing wp to the wp of the father.
bgt nUpdateB

; Updating minimum.
mov 6(sp), 36.(sp) ; Updating father wp to new minimum.
add #12., sp ; Popping all values besides registers backup.
mov (sp)+, r5
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0

; Restoring previous board and updating father src and dst.
; Restoring black piece previous location.
mov #2, (r2)
mov #0, @4.(sp)
; Checks if there was an eat:
tst 2(sp) ;
beq SrcDstB ; No eat. We don't need to restore. go to update src and dst.
; If we got here there was an eat and we need to restore it.
mov #1., @2.(sp) ; Restoring eaten white piece.
br SrcDstB

SrcDstB:
mov r2, 18.(sp) ; Updating father's SrcPos.
mov 4(sp), 16.(sp) ; Updating father's DstPos.
rts pc

nSrcDstB:
rts pc

upMaxB:
; The father is looking for maximum
cmp 6(sp), 36.(sp) ; Comparing wp to the wp of the father.
ble nUpdateB ; Jumps if we do not need to update.

; We need to update to new Maximum
mov 6(sp), 36.(sp) ; Updating father wp to new maximum.
add #12., sp ; Popping all values besides registers backup.
mov (sp)+, r5
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0

; Restoring previous board and updating father src and dst.
; Restoring black piece previous location.
mov #2, (r2)
mov #0, @4.(sp)
; Checks if there was an eat:
tst 2(sp) ;
beq SrcDstB ; No eat. We don't need to restore. go to update src and dst.
; If we got here there was an eat and we need to restore it.
mov #1., @2.(sp) ; Restoring eaten white piece.
br SrcDstB

nUpdateB:
add #12., sp ; Popping all values besides registers backup.
mov (sp)+, r5
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0
; Restoring previous board and updating father src and dst.
; Restoring black piece previous location.
mov #2, (r2)
mov #0, @4.(sp)
; Checks if there was an eat:
tst 2(sp) ;
beq nSrcDstB ; No eat. We don't need to restore. No need to update src and dst.
mov #1., @2.(sp) ; Restoring eaten white piece.
br nSrcDstB ; No need to update src and dst.
; END OF BlackMov


; This method will count how many vessles from each color are there on the
; given board.
; Input:
; Label of the beginning of the board - will be stored at 2(sp).
; Output:
; Number of white vessels - after rts will be stored at 4(sp).
; Number of black vessels - after rts will be stored at 2(sp).
;
; Notice: after rts 0(sp) will store the label of the board.
countWB:
mov r0, -(sp) ; Backing up r0. r0 will be used to scan the board.
mov r1, -(sp) ; Backing up r1. r1 will be used to count white vessels.
mov r2, -(sp) ; Backing up r2. r2 will be used to count black vessels.
mov r3, -(sp) ; Backing up r3. r3 will store the end of the board.
clr r1
clr r2
mov 10.(sp), r0 ; r0 = beginning of the board.
mov r0, r3 ; r3 = beginning of the board.
add #176, r3 ; r3 = end of the board.
cntloop:
tst (r0) ;
beq endloop ; if (r0) is 0 then no player in this cell.
cmp (r0), #1
bne .+6
inc r1 ; Current cell is white. r1++ .
br endloop ; Go to next cell.
inc r2 ; Current cell is black. r2++ .
jmp endloop ; Go to next cell.
endloop:
add #2, r0 ; r0 will point to next cell in the board.
cmp r0,r3
ble cntloop ; if we are still in the board limits - go to cntloop.
; If we got here we finished going through the entire board.
mov r1, 14.(sp) ; Writing white counter to stack.
mov r2, 12.(sp) ; Writing black counter to stack.
mov (sp)+, r3 ; Restoring the value of r3.
mov (sp)+, r2 ; Restoring the value of r2.
mov (sp)+, r1 ; Restoring the value of r1.
mov (sp)+, r0 ; Restoring the value of r0.
rts pc
; END OF countWB

; This method checks the given player has at least one legal move.
; Input:
; A number of player to check, will be at 2(sp).
; Output:
; A number of moves to add to, will be at (sp).
hasMove:
; r0 - Current row index.
; r1 - Current column index.
mov r0, -(sp) ; Saving r0's value on stack.
mov r1, -(sp) ; Saving r1's value on stack.
mov r2, -(sp) ; Saving r2's value on stack
mov r3, -(sp) ; Saving r3's value on stack
mov r5, -(sp); Saving r5's value on stack
clr r0 ; Sets r0 to 0.
clr r1 ; Sets r1 to 0.
cmp 14.(sp), #1 ; Checking if the current color is white.
bne chkBlack ; If the color is not white, branch to Black.
br chkWhite ; If the color is white, branch to White.

chkWhite:
; This method will check legal moves of all white pieces.
; r2- current cell pointer.
; r3 - temporary row index (will be used once for another calculation).
; r5 - temporary column index (will be used once for another calculation).

mov r0, r3  ; Putting index of the current row in r3.
mov r1, r5  ; Putting index of the current column in r5.
mov #Board, r2 ; Putting board array starting index in r2.
mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bits).
mul #2, r5 ; Multiplying the number of column by 2 (decimal) (length of each column in bits).
add r3, r2 ; Adding the number of bits needed in order to point to a start of a row.
add r5, r2 ; Adding the number of bits needed in order to point a cell in a row.
; r2 will now contain the address of the current cell.
cmp (r2), #1 ; Checking if the current piece is white.
bne SkipCell ; If the color of the current piece is not white skip to the next cell.
mov r0, r3 ; Setting r3 to the current row index (after changing it earlier).
sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt SkipCell ; If row index is less than 0, cannot move left or right, skip to the next cell.
mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
add #1, r5 ; Increasing column index by 1.
cmp r5, #7
bgt jLeftW01 ; If column index is bigger than 7, the current piece cannot move right, check legal moves to the left.
cmp -14.(r2), #1 ; Checking if the upper right piece is white.
beq jLeftW01 ; If the upper right piece is white, cannot go there, check legal moves to the left.
cmp -14.(r2), #2 ; Checking if the upper right piece is black.
beq eatrw1 ; If the upper right piece is black, check if the white piece can eat it.
add #1, 12.(sp) ; If we got here the upper right cell contains 0, the white piece can move there. Adding 1 to number of legal moves.
br canMove ;Found a legal move.


eatrw1:
;This method will check an eating option the right of white pieces.
; r2- current cell pointer.
; r3 - temporary row index .
; r5 - temporary column index.

sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt jLeftW01 ; If r3 is less than 0, cannot eat (out of bounds). Check legal moves to the left.
add #1, r5 ;Increasing column index by 1.
cmp r5, #7
bgt jLeftW01 ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the left.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, we need to check if it is empty.
cmp -28.(r2), #0 ; Checking if the cell is empty.
bne jLeftW01 ; If the cell is not empty, cannot eat. Check legal moves to the left.
add #1, 12.(sp) ;If we got here, can eat, adding 1 to number of legal moves.
br canMove ;Found a legal move.

jLeftW01:
; This method will check legal moves to the left of white pieces.
; r2- current cell pointer.
; r3 - temporary row index .
; r5 - temporary column index.

mov r0, r3 ; Putting index of the current row in r3.
sub #1, r3 ; Reducing row index by 1.
mov r1, r5 ; Putting index of the current column in r5.
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt SkipCell ; If column index is less than 0, cannot move right, skip to the next cell.
cmp -18.(r2), #1 ; Checking if the upper left piece is white.
beq SkipCell ; If the upper left piece is white, cannot move there, skip to the next cell.
cmp -18.(r2), #2 ; Checking if the upper left piece is black.
beq eatlw1 ; If the upper left piece is black, Check if the white piece can eat it.
add #1, 12.(sp) ; If we got here, upper left cell contains 0, can move there. Adding 1 to number of legal moves..
br canMove ;Found a legal move.

eatlw1:
;This method will check an eating option the left of white pieces.
; r2- current cell pointer.
; r3 - temporary row index .
; r5 - temporary column index.

sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt SkipCell ; If column index is less than 0, cannot eat, skip to the next cell.
sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt SkipCell ; If r3 is less than 0, cannot eat (out of bounds). Skip to the next cell.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
cmp -36.(r2), #0 ; Checking if the cell is empty.
bne SkipCell ;If the cell is not empty, cannot eat. Skip to the next cell.
add #1, 12.(sp) ;If we got here, can eat, adding 1 to legal number of moves on the stack.
br canMove ;Found a legal move.

canMove: ;If we got here we checked all the cells of the array or we got a legal move.
mov (sp)+, r5 ; Returning r5 it's original value.
mov (sp)+, r3 ; Returning r3 it's original value.
mov (sp)+, r2 ; Returning r2 it's original value.
mov (sp)+, r1 ; Returning r1 it's original value.
mov (sp)+, r0 ; Returning r0 it's original value.
rts pc ; When we return from this subroutine the output will be at the top of the stack

SkipCell:
; This method will skip to the next cell by adding 1 to column index. If column
; index is bigger than 7 sets it to 0 and adds 1 to row index.
; r0 - Current row index.
; r1 - Current column index.

add #1, r1
cmp r1, #8 ; Checking if passed end of row.
blt RangeOK ; Index of column is legal.
clr r1 ; If we got here index of column passed end of row. Set it to 0.
add #1, r0 ; Go to the next row.
cmp r0, #7
bgt canMove ; If index of row is bigger than 7 we reached the end of the board.

RangeOK:
;Continue on checking in the same row.
cmp 14.(sp), #1
bne chkBlack
br chkWhite

chkBlack:
; This method will check legal moves of all black pieces.
; r2- current cell pointer.
; r3 - temporary row index (will be used once for another calculation).
; r5 - temporary column index (will be used once for another calculation).

mov r0, r3  ; Putting index of the current row in r3.
mov r1, r5  ; Putting index of the current column in r5.
mov #Board, r2 ; Putting board array starting index in r2.
mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bits).
mul #2, r5 ; Multiplying the number of column by 2 (decimal) (length of each column in bits).
add r3, r2 ;Adding the number of bits needed in order to point to a start of a row.
add r5, r2 ; Adding the number of bits needed in order to point a cell in a row.
; r2 will now contain the address of the current cell.
cmp (r2), #2 ; Checking if the current piece is black.
bne SkipCell ; If the color of the current piece is not black skip to the next cell.
mov r0, r3 ; Putting index of the current row in r3.
add #1, r3 ; Increasing row index by 1.
cmp r3, #7
bgt SkipCell ; If row index is bigger than 7, cannot move left, skip to the next cell.
mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
add #1, r5 ; Increasing column index by 1.
cmp r5, #7
bgt RightB1 ; If column index is bigger than 7, the current piece cannot move left, Check legal moves to the right.
cmp 18.(r2), #2 ; Checking if the lower right piece is black.
beq RightB1 ; If the lower right piece is black, cannot go there, Check legal moves to the right.
cmp 18.(r2), #1 ; Checking if the lower right piece is black.
beq eatlb1 ; If the lower right piece is white, check if the black piece can eat it.
add #1, 12.(sp) ; If we got here the lower right cell contains 0, the black piece can move there. Adding 1 to number of legal moves.
br canMove ;Found a legal move.

eatlb1:
;This method will check an eating option the left of black pieces.
; r2- current cell pointer.
; r3 - temporary row index .
; r5 - temporary column index.

add #1, r3 ; Increasing row index by 1.
cmp r3, #7 ; If r3 is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
bgt RightB1
add #1, r5 ;Increasing column index by 1.
cmp r5, #7
bgt RightB1 ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
;If we got here, the cell which the current black piece should be placed after eating is in the board bounds, we need to check if it is empty.
cmp 36.(r2), #0 ; Checking if the cell is empty.
bne RightB1 ; If the cell is not empty, cannot eat. Check legal moves to the right.
add #1, 12.(sp) ;If we got here, can eat. Adding 1 to number of legal moves.
br canMove ;Found a legal move.

RightB1:
; This method will check legal moves to the right of black pieces.
; r2- current cell pointer.
; r3 - temporary row index .
; r5 - temporary column index.

mov r0, r3 ; Putting index of the current row in r3.
add #1, r3 ; Increasing row index by 1.
mov r1, r5 ; Putting index of the current column in r5.
sub #1, r5 ; Decreasing column index by 1.
cmp r5, #0
blt SkipCell ; If column index is less than 0, cannot move right, skip to the next cell.
cmp 14.(r2), #2 ; Checking if the lower left piece is black.
beq SkipCell ; If the lower left piece is white, cannot move there, skip to the next cell.
cmp 14.(r2), #1 ; Checking if the lower left piece is white.
beq eatrb1 ; If the lower left piece is white, check if the black piece can eat it.
add #1, 12.(sp) ; If we got here the lower left cell contains 0, the black piece can move there. Adding 1 to number of legal moves.
br canMove ;Found a legal move.

eatrb1:
; This method will check an eating option the right of black pieces.
; r2- current cell pointer.
; r3 - temporary row index .
; r5 - temporary column index.

sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt SkipCell ; If column index is less than 0, cannot eat, skip to the next cell.
add #1, r3 ; Increasing row index by 1.
cmp r3, #7
bgt SkipCell ; If r3 is bigger than 7, cannot eat (out of bounds). Skip to the next cell.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
cmp 28.(r2), #0 ; Checking if the cell is empty.
bne SkipCell ;If the cell is not empty, cannot eat. Skip to the next cell.
add #1, 12.(sp) ;If we got here, can eat. Adding 1 to number of legal moves.
br canMove ;Found a legal move.
; END OF hasMove




;==============================================================================
;                             END OF FUNCTIONS
;==============================================================================

.=torg + 16000
command: .blkw 25.
pointer: .blkw 1
curChar: .byte 1
.even
gameOn: .word 0
errorCom: .blkw 25.
errPtr: .blkw 1
putDolar: .word 0

turn: .word 1
source: .word 0
dest: .word 0
WinParam: .word 0
Steps: .word 0



wPlayer: .byte 0
.even
wTime: .word 0
wTimeStr: .blkw 25.
wTimePtr: .word 0
bPlayer: .byte 0
.even
bTime: .word 0
bTimeStr: .blkw 25.
bTimePtr: .word 0

.even
TIMOUT:.word 0
tcounter:.word 0
msctr:.word 0

;========================================================================
;                            STRINGS
;========================================================================

.even
cannot: .ascii <Cannot\sexecute\s"\0>
dollar: .ascii <$ \0>
welcome:.ascii <Welcome\sto\s312433576\sand\s203438775\scheckers\sgame!\r>
newgame: .ascii<Starting\sa\snew\sgame\r>
Wplyris: .ascii<White\splayer\sis\s\0>
Bplyris: .ascii<Black\splayer\sis\s\0>
hmn: .ascii<Human\s\0>
computer: .ascii<Computer\s\0>
with: .ascii <with\s\0>
secpermov: .ascii< seconds\sper\smove\r>
boardlay: .ascii<Board layout:\r>
nlfeed: .ascii<\r>
CPStr: .ascii <Current\sPlayer:\s\0>
Blk: .ascii <Black\s\0>
Wht: .ascii <White\s\0>
movStr: .ascii <move\s\0>
tookStr: .ascii <took\s\0>
secStr: .ascii <seconds\0>
dotStr: .ascii <.\r>
gameOver: .ascii <is\sout\sof\stime.\sGame\sOver.\r>
wplyris: .ascii<white\splayer\sis\s\0>
bplyris: .ascii<black\splayer\sis\s\0>
WPfor: .ascii<WP\sfor\s\0>
playerWin: .ascii<player\swins!\r>
timelstr: .ascii<\0\0\0\0\0\0\0\0>
tlefstr: .ascii <Time\sLeft:\s\0>
itsATie: .ascii <It's\sa\stie!\sGame\sover.\r>

.even
Board:.word	0,	0,	0,	2,	0,	0,	0,	2
			.word	0,	0,	2,	0,	2,	0,	2,	0
			.word	0,	1,	0,	1,	0,	2,	0,	1
			.word	1,	0,	0,	0,	0,	0,	0,	0
			.word	0,	0,	0,	0,	0,	0,	0,	0
			.word	1,	0,	1,	0,	1,	0,	1,	0
			.word	0,	1,	0,	1,	0,	1,	0,	1
			.word	1,	0,	1,	0,	1,	0,	1,	0

NewBoard:
  .word	0,	2,	0,	2,	0,	2,	0,	2
	.word	2,	0,	2,	0,	2,	0,	2,	0
	.word	0,	2,	0,	2,	0,	2,	0,	2
	.word	0,	0,	0,	0,	0,	0,	0,	0
	.word	0,	0,	0,	0,	0,	0,	0,	0
	.word	1,	0,	1,	0,	1,	0,	1,	0
	.word	0,	1,	0,	1,	0,	1,	0,	1
	.word	1,	0,	1,	0,	1,	0,	1,	0
