tks = 177560
tkb = 177562
tps = 177564
tpb = 177566
lcs = 177546
asciimask = 177760

.=torg + 60
.word rInput
.word 200

.=torg + 100
.word clock
.word 300

.=torg + 1000
main:
; Initializing stack
mov pc, sp
tst -(sp)
mov #welcome, -(sp)
jsr pc, printStr
tst (sp)+
jsr pc, printNL ; Printing new line
mov #command, pointer
mov #101,@#tks ; keyboard interrupt = 1 && RE = 1
w:
cmp putDolar, #0
bne cont1
mov #1, putDolar
jsr pc, printdol ; Printing $ if needed
cont1:

cmp gameOn, #1
bne cont1
; Game is on
cmp turn, #1
beq whitTurn
; Black player's turn
jsr pc, printBCP ; Printing black current player
jsr pc, printNL ; Printing new line
jsr pc, printdol ; Printing $ if needed
mov r1, -(sp)
mov bTime, r1
mul rate, r1
mov r1, tcounter ;Setting white player's time.
mov (sp)+, r1
mov #100, @#lcs ;Clock is on.
cmpb #1, bPlayer
bne bCpu
;Black player is Human
BHmnTrn: ; Black human turn
tst gameOn
beq endGBj
cmp #0, TIMOUT
beq BHmnTrn
cmp #-1., TIMOUT
beq BHTend ; Black Human Turn End
;-------------------------------------------------------------------------------
; todo : Print out of time game over.
mov #Blk, -(sp)
jsr pc, printStr
tst (sp)+
mov #hmn, -(sp)
jsr pc, printStr
tst (sp)+
mov #gameOver, -(sp)
jsr pc, printStr
tst (sp)+
jsr pc, printNL
;-------------------------------------------------------------------------------
mov #0, TIMOUT
mov #0, @#lcs
mov #0, gameOn ; Game End
jmp w
BHTend:
; Black Human Turn End
mov #0, TIMOUT
jmp cont1

bCpu:
;Call recursive function.
mov #source, -(sp)
mov #dest, -(sp)
mov #WinParam, -(sp)
mov #1, Steps ; Setting steps to 1.
jsr pc, getMaxWP
add #6, sp
tst gameOn
beq endGBj
mov source, -(sp)
mov dest, -(sp)
jsr pc, movPiece
add #4, sp ;Popping source and dest.
mov #0, TIMOUT
mov #0, @#lcs
jsr pc, chgTurn
;todo: print how much time the move took.
jsr pc, printB ; Print board.
jmp cont1

endGBj: jmp endGameB

endGWj: jmp endGameW

whitTurn:
jsr pc, printWCP ; Printing white current player
jsr pc, printNL ; Printing new line
jsr pc, printdol ; Printing $ if needed
mov r1, -(sp)
mov wTime, r1
mul rate, r1
mov r1, tcounter ;Setting white player's time.
mov (sp)+, r1
mov #100, @#lcs ;Clock is on.
cmpb #1, wPlayer
bne wCpu
;White player is human
WHmnTrn: ; White human turn
tst gameOn
beq endGWj
cmp #0, TIMOUT
beq WHmnTrn
cmp #-1., TIMOUT
beq WHTend ; White Human Turn End
;-------------------------------------------------------------------------------
; todo : Print out of time game over.
mov #Wht, -(sp)
jsr pc, printStr
tst (sp)+
mov #hmn, -(sp)
jsr pc, printStr
tst (sp)+
mov #gameOver, -(sp)
jsr pc, printStr
tst (sp)+
jsr pc, printNL

;-------------------------------------------------------------------------------
mov #0, TIMOUT
mov #0, @#lcs
mov #0, gameOn ; Game End
jmp w
WHTend:
mov #0, TIMOUT
jmp cont1

wCpu:
;Call recursive function.
mov #source, -(sp)
mov #dest, -(sp)
mov #WinParam, -(sp)
mov #1, Steps ; Setting steps to 1.
jsr pc, getMaxWP
add #6, sp
tst gameOn
beq endGWj
mov source, -(sp)
mov dest, -(sp)
jsr pc, movPiece
add #4, sp ;Popping source and dest.
mov #0, TIMOUT
mov #0, @#lcs
jsr pc, chgTurn
;todo: print how much time the move took.
jsr pc, printB
jmp cont1

endGameW:
mov #0, @#lcs
mov #WPfor, -(sp)
jsr pc, printStr
tst (sp)+
mov #wplyris, -(sp)
jsr pc, printStr
tst (sp)+
mov r4, -(sp)
mov #Board, -(sp)
mov turn, -(sp)
jsr pc, calcWP
mov r4, WinParam
add #4, sp
mov (sp)+, r4
jsr pc, printWP
jsr pc, printNL
jsr pc, printWin
jsr pc, printNL
jmp w

endGameB:
mov #0, @#lcs
mov #WPfor, -(sp)
jsr pc, printStr
tst (sp)+
mov #bplyris, -(sp)
jsr pc, printStr
tst (sp)+
mov r4, -(sp)
mov #Board, -(sp)
mov turn, -(sp)
jsr pc, calcWP
mov r4, WinParam
add #4, sp
mov (sp)+, r4
jsr pc, printWP
jsr pc, printNL
jsr pc, printWin
jsr pc, printNL
jmp w


; Read input
rInput:
movb @#tkb, curChar

; Check if we reached the end of the command
mov r0, -(sp) ; Backing up r0
mov #command, r0 ; Moving command string address to r0
add #50., r0 ; Adding max length of string to r0.
cmp pointer, r0 ; Checks if the command reached 50 chars.
bgt ignore
; We have not reached the end of the command
cmpb curChar, #'\r  ; checks if current char is ENTER
beq endOfIpt
cmpb #'\b, curChar  ; checks if current char is BackSpace
beq backspace
; Current char is a neither ENTER nor BackSpace
movb curChar, @pointer
movb curChar, @#tpb ; sending char to print
loop: tstb @#tps
bpl loop
; curChar was printed
inc pointer
mov (sp)+, r0 ; Restores r0.
inc @#tks ; RE = 1
rti

endOfIpt:
jsr pc, printNL ; Printing new line
movb #0, @pointer ; Adds linefeed to the command string.
mov #command, pointer ; Pointer will point the beginning of the command
mov (sp)+, r0 ; Restoring r0
jsr pc, decode ; Decoding the command
mov #command, pointer ; Pointer will point the beginning of the command
mov #0, putDolar
inc @#tks ; RE = 1
rti





backspace:
cmp #command, pointer
beq ignore
dec pointer
movb #'\b, @#tpb
wait0:		tstb @#tps
bpl wait0
movb #' , @#tpb
wait1:		tstb @#tps
bpl wait1
movb #'\b, @#tpb
wait2:		tstb @#tps
bpl wait2
inc @#tks ; RE = 1
mov (sp)+, r0 ; Restoring r0
rti
ignore:
mov (sp)+, r0 ; Restoring r0
inc @#tks ; RE = 1
rti

decode:
cmpb @pointer, #'s
beq sCom
cmpb @pointer, #'t
beq tCom
cmpb @pointer, #'m
beq mCom
jmp noCom

sCom:
inc pointer
cmpb @pointer, #'t
bne noCom
inc pointer
cmpb @pointer, #'a
beq staCom
cmpb @pointer, #'o
bne noCom
; If we got here we had the sequence 'sto'
inc pointer
cmpb @pointer, #'p
bne noCom
jmp stopCom

staCom:
; If we got here we had the sequence 'sta'
inc pointer
cmpb @pointer, #'r
bne noCom
inc pointer
cmpb @pointer, #'t
bne noCom
inc pointer
cmpb #' , @pointer
bne noCom
jmp startCom


tCom:
; If we got here we had 't'
inc pointer
cmpb @pointer, #'i
bne noCom
inc pointer
cmpb @pointer, #'m
bne noCom
inc pointer
cmpb @pointer, #'e
bne noCom
jmp timeCom

mCom:
; If we got here we had 'm'
inc pointer
cmpb @pointer, #'o
bne noCom
inc pointer
cmpb @pointer, #'v
bne noCom
inc pointer
cmpb @pointer, #'e
bne noCom
inc pointer
cmpb #' , @pointer
bne noCom
jmp moveCom

;-------------------------------------------------------------------------------
;                           Illegal command
;-------------------------------------------------------------------------------
noCom:
; Prints cannot execute..
jsr pc, printNL ; Printing new line
mov #cannot, -(sp)
jsr pc, printStr
tst (sp)+
mov #command, pointer
mov #errorCom, errPtr
cpyErr:
cmpb  #' , @pointer
beq donecpy
cmpb  #0 , @pointer
beq donecpy
movb @pointer, @errPtr
inc errPtr
inc pointer
jmp cpyErr

donecpy:
movb #'", @errPtr
inc errPtr
movb #'\r, @errPtr
mov #errorCom, -(sp)
jsr pc, printStr
tst (sp)+
mov #command, pointer
jsr pc, printNL ; Printing new line
jsr pc, printdol
rts pc ; return from decode
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                           Command is 'start'
;-------------------------------------------------------------------------------
startCom:
inc pointer
cmpb  #' , @pointer
beq startCom ; skipping spaces
; Spaces skipped
setWplyr: ; Set white player
cmpb @pointer, #'h
beq wHuman
cmpb @pointer, #'c
beq wPC
jmp noCom

wHuman:
mov #1, wPlayer
; Checks if after 'h' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer
bne noCom
dec pointer
jmp setwTime
wPC:
mov #2, wPlayer
; Checks if after 'c' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer
bne noCom
dec pointer
jmp setwTime

setwTime:
mov #0, wTime ; White Time
inc pointer
cmpb #' , @pointer
beq setwTime ; skipping spaces
cmpb @pointer, #'0
blt noCom ; jumps if not a number
cmpb @pointer, #'9
bgt noCom ; jumps if not a number
jsr pc, RstBWStr ; Reseting values of wTimeStr and bTimeStr
; If we got here it is a number
rdWTime: ; Read White player time
mov r1, -(sp) ; Backing up r1
mov wTime, r1
mul #10., r1
mov r1, wTime
mov (sp)+, r1
mov r0, -(sp) ; Backing up r0
movb @pointer, @wTimePtr ; copy ascii number to a string (will be printed later)
inc wTimePtr
movb @pointer, r0
bic #asciimask, r0
add r0, wTime
mov (sp)+, r0
inc pointer
cmpb #' , @pointer
beq setBplyr ; Set Black Player
cmpb @pointer, #'0
blt jnoCom ; jumps if not a number
cmpb @pointer, #'9
bgt jnoCom ; jumps if not a number
jmp rdWTime ; Read White Time

setBplyr:
inc pointer
cmpb  #' , @pointer
beq setBplyr ; skipping spaces
cmpb @pointer, #'h
beq bHuman
cmpb @pointer, #'c
beq bPC
jmp noCom

bHuman:
mov #1, bPlayer
; Checks if after 'h' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer
bne jnoCom
dec pointer
jmp setbTime ; Set Black Time

bPC:
mov #2, bPlayer
; Checks if after 'c' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer
bne jnoCom
dec pointer
jmp setbTime ; Set Black Time

                  jnoCom: jmp noCom

setbTime:
mov #0, bTime
inc pointer
cmpb #' , @pointer
beq setbTime ; skipping spaces
cmpb @pointer, #'0
blt jnoCom ; jumps if not a number
cmpb  @pointer, #'9
bgt jnoCom ; jumps if not a number
; If we got here it is a number
rdBTime: ; Read Black player time
mov r1, -(sp) ; Backing up r1
mov bTime, r1
mul #10., r1
mov r1, bTime
mov (sp)+, r1
mov r0, -(sp) ; Backing up r0
movb @pointer, @bTimePtr ; copy ascii number to a string (will be printed later)
inc bTimePtr
movb @pointer, r0
bic #asciimask, r0
add r0, bTime
mov (sp)+, r0
inc pointer
cmpb @pointer, #'0
blt startChk ; jumps if not a number
cmpb @pointer, #'9
bgt startChk ; jumps if not a number
jmp rdBTime ; Read Black Time

startChk:
cmpb @pointer, #0
bne jnoCom
cmp gameOn, #0
bne jnoCom
jmp startOK

startOK:
mov #1, gameOn
jsr pc, printNL ; Printing new line
jsr pc, Start

rts pc ; Return from decode

Start:
mov #newgame, -(sp)
jsr pc, printStr
tst (sp)+
jsr pc, printNL ; Printing new line
jsr pc, printWPI ; Printing "White player is "
cmpb #1, wPlayer
beq wplyrHmn ; White Player Human
; White player is computer
jsr pc, printPC ; Printing "Computer "
br wplyrtime ; White Player Time
wplyrHmn:
; White player is human
jsr pc, printHmn ; Printing "Human "
br wplyrtime

wplyrtime:
; Printing time for white player
mov #with, -(sp)
jsr pc, printStr
tst (sp)+

jsr pc, printWPT ; print White Player Time

jsr pc, printSPM ; Printing "seconds per move\r"
jsr pc, printNL ; Printing new line


jsr pc, printBPI ; Printing "Black player is "
cmpb bPlayer, #1
beq bplyrHmn ; Black Player Human
; Black player is Computer
jsr pc, printPC ; Printing "Computer "
br bplyrtime
bplyrHmn:
; Black player is Human
jsr pc, printHmn ; Printing "Human "
br bplyrtime

bplyrtime:
; Printing time for white player
mov #with, -(sp)
jsr pc, printStr
tst (sp)+

jsr pc, printBPT ; print Black Player Time
jsr pc, printSPM ; Printing "seconds per move\r"
jsr pc, printNL ; Printing new line

mov #1, turn
mov #0, tcounter
mov #0, WinParam
jsr pc, initBoard ; Initializing the board
jsr pc, printB ; Printing the board


rts pc ; Return from decode
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                            jnoCom1: jmp noCom

;-------------------------------------------------------------------------------
;                           Command is 'stop'
;-------------------------------------------------------------------------------
stopCom:
tst gameOn
beq jnoCom1
mov #0, gameOn ; Stopping the game
jsr pc, printNL
rts pc ; Return from decode
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                           Command is 'time'
;-------------------------------------------------------------------------------
timeCom:

;-------------------------------------------------------------------------------
; todo: enter here code to print time left of the turn
;-------------------------------------------------------------------------------

rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                           Command is 'move'
;-------------------------------------------------------------------------------
moveCom:
; The command is 'move'
cmp gameOn, #0
beq jnoCom1
cmpb  #' , @pointer
bne continue
inc pointer ; Skipping spaces.
br moveCom
continue:
cmpb @pointer, #'0
blt jnoCom1
cmpb  @pointer, #'7
bgt jnoCom1
mov r0, -(sp)  ; Backing up r0.
mov r1, -(sp)  ; Backing up r1.
mov r2, -(sp)  ; Backing up r2.
mov r3, -(sp)  ; Backing up r3.
mov r4, -(sp)  ; Backing up r4.
mov r5, -(sp)  ; Backing up r5.
clr r1
movb @pointer, r0
bic #asciimask, r0
mov r0, r2 ; r2 will be used for row index.
mov r0, r1
asl r1
asl r1
asl r1
inc pointer ;Get next index character.
cmpb @pointer, #'0
blt badIdxj
cmpb  @pointer, #'7
bgt badIdxj
movb @pointer, r0
bic #asciimask, r0
mov r0, r3 ; r3 will be used for column index.
add r0, r1
mul #2, r1 ;Multiplying by 2 (each word is 2 bytes).
add #Board, r1
mov r1, source ; source will hold source board adress.
cmp (r1), turn ;Checks if a piece of the current player is found in the given index.
bne badIdxj
inc pointer
skip:
cmpb  #' , @pointer
bne cont2
inc pointer ; Skipping spaces.
br skip
cont2:
cmpb @pointer, #'0
blt badIdxj
cmpb  @pointer, #'7
bgt badIdxj
clr r1
movb @pointer, r0
bic #asciimask, r0
add r0, r1
asl r1
asl r1
asl r1
inc pointer ;Get next index character.
cmpb @pointer, #'0
blt badIdxj
cmpb @pointer, #'7
bgt badIdxj
movb @pointer, r0
bic #asciimask, r0
add r0, r1
mul #2, r1 ;Multiplying by 2 (each word is 2 bytes).
add #Board, r1
mov r1, dest ;dest will now hold desteation board adress.
cmp dest, source
beq badIdxj ; Checks if source == dest.
cmp #1, turn
bne bIdxChk ; Black index Check
;Checking if the desteation adress is legal for white player.
cmp source, dest
blt badIdxj ; If source<dest white is trying to move down instead of up.
mov r2, r4 ;Using r4 as temporary row index.
sub #1, r4 ; Reducing row index by 1.
cmp r4, #0
blt badIdxj ; If row index is less than 0, cannot move left or right.
mov r3, r5 ;Using r5 as temporary column index.
add #1, r5 ; Increasing column index by 1.
cmp r5, #7
bgt LeftWmv ; If column index is bigger than 7, the current piece cannot move right.
; If we got here the desteation index can be the upper right cell.
mov source, r1
cmp -14.(r1), #1 ; Checking if the upper right piece is white.
beq LeftWmv ; If the upper right piece is white, cannot go there, check legal moves to the left.
cmp -14.(r1), #2 ; Checking if the upper right piece is black.
beq eatrwmv ; If the upper right piece is black, check if the white piece can eat it.
; If we got here we need to check if the desteation adress equals to the left right cell adress.
sub #14., r1
cmp r1, dest
beq destFj
jmp LeftWmv ; Keep on checking legal moves to the left (cannot eat so we don't need to check an eating option).

badIdxj:
  jmp badIdx

destFj:
  jmp destFound

eatrwmv:
sub #1, r4 ; Reducing row index by 1.
cmp r4, #0
blt LeftWmv ; If r4 is less than 0, cannot eat (out of bounds). Check legal moves to the left.
add #1, r5 ;Increasing column index by 1.
cmp r5, #7
bgt LeftWmv ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the left.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, we need to check if it is empty.
mov source, r1
cmp -28.(r1), #0 ; Checking if the cell is empty.
bne LeftWmv ; If the cell is not empty, cannot eat. Check legal moves to the left.
; If we got here we need to check if dest == upper right cell (after eating).
sub #28., r1
cmp dest, r1
beq destFj

LeftWmv:
mov r2, r4 ; Putting index of the current row in r4.
sub #1, r4 ; Reducing row index by 1.
mov r3, r5 ; Putting index of the current column in r5.
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt badIdxj ; If column index is less than 0, cannot move right, dest is not a legal cell adress.
mov source, r1
cmp -18.(r1), #1 ; Checking if the upper left piece is white.
beq badIdxj ; If the upper left piece is white, cannot move there, dest is not a legal cell adress.
cmp -18.(r1), #2 ; Checking if the upper left piece is black.
beq eatlwmv ; If the upper left piece is black, Check if the white piece can eat it.
sub #18., r1
cmp dest, r1
beq destFj
jmp badIdxj ; If we got here there are no more moves to check and desteation adress wans't found.

eatlwmv:
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt badIdxj ; If column index is less than 0, cannot eat, dest is not a legal cell adress.
sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt badIdxj ; If r3 is less than 0, cannot eat (out of bounds). dest is not a legal cell adress.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
mov source,r1
cmp -36.(r1), #0 ; Checking if the cell is empty.
bne badIdxj ;If the cell is not empty, cannot eat. Skip to the next cell.
sub #36., r1
cmp dest, r1
beq destFound
jmp badIdxj ; No more moving options.

bIdxChk:
cmp source, dest
bgt badIdxj ; If source>dest black is trying to move up instead of down.
mov r2, r4 ; Putting index of the current row in r4.
add #1, r4 ; Increasing row index by 1.
cmp r4, #7
bgt badIdxj ; If row index is bigger than 7, cannot move left, dest adress cannot be legal.
mov r3, r5 ; Setting r5 to the current column index (after changing it eariler).
add #1, r5 ; Increasing column index by 1.
cmp r5, #7
bgt RightBmv ; If column index is bigger than 7, the current piece cannot move left, Check legal moves to the right.
mov source, r1
cmp 18.(r1), #2 ; Checking if the lower right piece is black.
beq RightBmv ; If the lower right piece is black, cannot go there, Check legal moves to the right.
; If we got here the desteation index can be the lower right cell.
cmp 18.(r1), #1 ; Checking if the lower right piece is black.
beq eatlbmv ; If the lower right piece is white, check if the black piece can eat it.
add #18., r1
cmp dest, r1
beq destFound
br RightBmv ; Keep on checking legal moves to the right (cannot eat so we don't need to check an eating option).

eatlbmv:
add #1, r4 ; Increasing row index by 1.
cmp r4, #7 ; If r3 is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
bgt RightBmv
add #1, r5 ;Increasing column index by 1.
cmp r5, #7
bgt RightBmv ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
;If we got here, the cell which the current black piece should be placed after eating is in the board bounds, we need to check if it is empty.
mov source, r1
cmp 36.(r1), #0 ; Checking if the cell is empty.
bne RightBmv ; If the cell is not empty, cannot eat. Check legal moves to the right.
add #36., r1
cmp dest, r1
beq destFound

RightBmv:
mov r2, r4 ; Putting index of the current row in r3.
add #1, r4 ; Increasing row index by 1.
mov r3, r5 ; Putting index of the current column in r5.
sub #1, r5 ; Decreasing column index by 1.
cmp r5, #0
blt badIdxju ; If column index is less than 0, cannot move right, desteation adress cannot be legal.
mov source, r1
cmp 14.(r1), #2 ; Checking if the lower left piece is black.
beq badIdxju ; If the lower left piece is white, cannot move there, desteation adress cannot be legal.
cmp 14.(r1), #1 ; Checking if the lower left piece is white.
beq eatrbmv ; If the lower left piece is white, check if the black piece can eat it.
add #14., r1
cmp dest, r1
beq destFound
jmp badIdxj ;No more moving options.

badIdxju:
jmp badIdx

eatrbmv:
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt badIdxju ; If column index is less than 0, cannot eat, desteation adress cannot be legal.
add #1, r4 ; Increasing row index by 1.
cmp r4, #7
bgt badIdxju ; If r3 is bigger than 7, cannot eat (out of bounds). Skip to the next cell.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
mov source, r1
cmp 28.(r1), #0 ; Checking if the cell is empty.
bne badIdxju ;If the cell is not empty, cannot eat.
add #28., r1
cmp dest, r1
beq destFound
jmp badIdxj ; No more moving options.

destFound:
mov (sp)+, r5
mov (sp)+, r4
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1 ;Restores r1's value.
mov (sp)+, r0 ;Restores r0's value.
mov source, -(sp)
mov dest, -(sp)
jsr pc, movPiece
add #4, sp ;Popping source and dest.

mov #0, @#lcs ; Stopping the clock
mov #-1., TIMOUT ; Player Moved successfully.

jsr pc, printNL ; Printing new line
cmp turn, #1
beq whitMv
; Black Player Turn
jsr pc, printBLK ; Printing: 'Black '
jmp zibby

whitMv:

jsr pc, printWHT
zibby:
jsr pc, printHmn ; Printing: 'Human '
jsr pc, printMT ; Printing: 'move took '

;-------------------------------------------------------------------------------
; todo: print how much time did it take from human to make a move
;-------------------------------------------------------------------------------
mov #secStr, -(sp)
jsr pc, printStr
tst (sp)+
mov #dotStr, -(sp)
jsr pc, printStr
tst (sp)+
jsr pc, printB ; Printing Board
jsr pc, chgTurn
rts pc

badIdx:
mov (sp)+, r5
mov (sp)+, r4
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0
jmp noCom
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                           Clock interrupt
;-------------------------------------------------------------------------------
clock:
dec tcounter
tst tcounter
beq timeUp
rti
timeUp:

mov #1, TIMOUT

rti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;===============================================================================
;                                FUNCTIONS
;===============================================================================
;-------------------------------------------------------------------------------
;                                movPiece
;-------------------------------------------------------------------------------
; This method will move a player from the source position to the destanation
; position.
;
; Input:
; 1. Destination position - will be stored at 2(sp).
; 2. Source position - will be stored at 4(sp).

movPiece:
 mov r1, -(sp) ; Backing up  r1.
 mov r3, -(sp) ; Backing up  r3.
 mov 10(sp), r1 ; r1 = Adress of source position.
 mov 6(sp), r3 ; r3 = Adress of destanation position.

 ; Making the changes.
 mov (r1), (r3) ; board[dest] = board[source].
 mov #0, (r1) ; board[source] = 0.

 ; Now we need to check if there was an eat. We will find the address
 ; in the middle between the source address and the dest address.
 ; Notice that if there was an eat then the address of the eaten cell
 ; is a multiply of 2 and is equal to: (src_addr + dest_addr)/2 .
 ; In that case we also need to put 0 in that place.
 ; If there was no eat then the address of the middle cell is not a
 ; multiply of 2 and so we need to finish the function.
 mov r0, -(sp) ; Backing up r0.
 clr r0
 add r3, r1 ; r1 = source address + dest address
 div #2, r0  ; r0 will hold the address of the eaten cell in case of eat.
 mov r0, -(sp) ; Backing up the address of the eaten cell.
 ; Now we have the potenitally eaten cell address. we need to check if
 ; that eaten cell address is a multiply of 2.
 clr r0
 mov (sp), r1 ; r1 = eaten cell address.
 div #2, r0 ; r1 will hold the remainer.
 cmp r1, #0 ;
 bne endmop ; if the remainer is not zero there was no eat. goto endmop.
 ; If we got here then the remainer is zero. it means that there was an
 ; eat and we need to put 0 in the eaten place.
 ; Notice that the eaten cell address is at sp.
 mov #0, @(sp)
; Method is done. Restoring registers.
endmop:
tst (sp)+ ; popping the eaten cell address (no longer needed).
mov (sp)+, r0 ; Restoring value of r0.
mov (sp)+, r3 ; Restoring value of r4.
mov (sp)+, r1 ; Restoring value of r3.
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                PrintStr
;-------------------------------------------------------------------------------
printStr:
tstb @#tps ;Busy wait, wait till end of print.
bpl printStr
cmpb #'\0, @2(sp) ; Check if reached end of string.
beq sof
cmpb #'\r, @2(sp) ;Check if reached end of string and needs to print a new line.
beq newline
movb @2(sp), @#tpb ;Print char.
inc 2(sp) ; Move to the next char.
br printStr
newline:
tstb @#tps ;Busy wait, wait till end of print.
bpl newline
movb #'\r, @#tpb ;Prints carrige return.
wx: tstb @#tps ;Busy wait, wait till end of print.
bpl wx
movb #'\n, @#tpb ; Prints a new line.
wz: tstb @#tps ;Busy wait, wait till end of print.
bpl wz
sof:
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;-------------------------------------------------------------------------------
;                                printdol
;-------------------------------------------------------------------------------
printdol:
; Printing "$"
mov #dollar, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printHmn
;-------------------------------------------------------------------------------
printHmn:
; Printing "Human "
mov #hmn, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printPC
;-------------------------------------------------------------------------------
printPC:
; Printing "Computer "
mov #computer, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printSPM
;-------------------------------------------------------------------------------
printSPM:
; Printing " seconds per move\r"
mov #secpermov, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printBPI
;-------------------------------------------------------------------------------
printBPI:
; Printing "Black player is "
mov #Bplyris, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printWPI
;-------------------------------------------------------------------------------
printWPI:
; Printing "White player is "
mov #Wplyris, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printBPT
;-------------------------------------------------------------------------------
printBPT:
; Printing how much time the black player has to move
mov #bTimeStr, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printWHT
;-------------------------------------------------------------------------------
printWHT:
; Printing: "White "
mov #Wht, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printBLK
;-------------------------------------------------------------------------------
printBLK:
; Printing: "Black "
mov #Blk, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printWPT
;-------------------------------------------------------------------------------
printWPT:
; Printing how much time the black player has to move
mov #wTimeStr, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printNL
;-------------------------------------------------------------------------------
printNL:
; Printing new line
mov #nlfeed, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printMT
;-------------------------------------------------------------------------------
printMT:
; Printing: 'move took '
mov #movStr, -(sp)
jsr pc, printStr
tst (sp)+
mov #tookStr, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printBL
;-------------------------------------------------------------------------------
printBL:
; Printing 'Board layout:\r'
mov #boardlay, -(sp)
jsr pc, printStr
tst (sp)+
jsr pc, printNL ; Printing new line
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                chgTurn
;-------------------------------------------------------------------------------
chgTurn:
; Changing turn
mov r0, -(sp)
mov #3, r0
sub turn, r0
mov r0, turn
mov (sp)+, r0
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printWCP
;-------------------------------------------------------------------------------
printWCP:
; Printing: 'Current Player: White'
mov #CPStr, -(sp)
jsr pc, printStr
tst (sp)+
mov #Wht, -(sp)
jsr pc, printStr
tst (sp)+
cmp #1, wPlayer
beq whitpl
; White Player is computer
mov #computer, -(sp)
jsr pc, printStr
tst (sp)+
jmp endWCP
whitpl:
; White player is Human
mov #hmn, -(sp)
jsr pc, printStr
tst (sp)+
endWCP:
jsr pc, printNL ; Printing new line
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printWP
;-------------------------------------------------------------------------------
printWP:
mov r0, -(sp)
mov r1, -(sp)
clr r0
mov WinParam, r1
tst WinParam
bpl positWP ; Positive WP
mul #-1., r1
movb #'-, @#tpb
tstb @#tps
bpl .-4
positWP:
div #10., r0
add #60, r1
tst r0
beq endWP
add #60, r0
movb r0, @#tpb
tstb @#tps
bpl .-4
endWP:
movb r1, @#tpb
tstb @#tps
bpl .-4
mov (sp)+, r1
mov (sp)+, r0
jsr pc, printNL
rts pc


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printBCP
;-------------------------------------------------------------------------------
printBCP:
; Printing: 'Current Player: black'
mov #CPStr, -(sp)
jsr pc, printStr
tst (sp)+
mov #Blk, -(sp)
jsr pc, printStr
tst (sp)+
cmp #1, bPlayer
beq blkpl
; Black Player is computer
mov #computer, -(sp)
jsr pc, printStr
tst (sp)+
jmp endBCP
blkpl:
; White player is Human
mov #hmn, -(sp)
jsr pc, printStr
tst (sp)+
endBCP:
jsr pc, printNL ; Printing new line
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;-------------------------------------------------------------------------------
;                                printWin
;-------------------------------------------------------------------------------
printWin:
tst WinParam
beq isTie
tst WinParam
bgt curWin
;Current player didn't win
cmp turn, #1
beq Blackwin
br Whitewin
curWin:
cmp turn, #1
beq Whitewin
Blackwin:
jsr pc, printBLK
mov #playerWin, -(sp)
jsr pc, printStr
tst (sp)+
rts pc
Whitewin:
jsr pc, printWHT
mov #playerWin, -(sp)
jsr pc, printStr
tst (sp)+
isTie:
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                RstBWStr
;-------------------------------------------------------------------------------
RstBWStr:
; Resets values of bTimeStr and wTimeStr
mov r0, -(sp) ; Backing up r0
mov #25., r0
mov #bTimeStr, bTimePtr
mov #wTimeStr, wTimePtr
loopRst:
mov #0, @bTimePtr
add #2, bTimePtr
mov #0, @wTimePtr
add #2, wTimePtr
sub #1, r0
cmp r0, #0
bne loopRst
mov #bTimeStr, bTimePtr
mov #wTimeStr, wTimePtr
mov (sp)+, r0 ; Restoring r0
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                printB
;-------------------------------------------------------------------------------
printB:
; Printing board
jsr pc, printNL ; Printing new line
jsr pc, printNL ; Printing new line
jsr pc, printNL ; Printing new line
jsr pc, printBL ; Printing 'Board layout:\r'
mov r0, -(sp) ; Backing up r0.
mov r1, -(sp) ; Backing up r1.
mov r2, -(sp) ; Backing up r2.
mov #8., r2
mov #Board, r1
add #128., r1
mov #Board, r0
Ploop:
cmp r0, r1
beq endP
tst r2 ; R2 will be initialized with 8 (number of words to print per row).
bne conP
mov #8., r2
jsr pc, printNL ; Printing new line
conP:
cmp (r0), #0 ;Check if we need to print _.
beq print_
cmp (r0), #1 ;Check if we need to print W.
beq printWH
tst (r0) ; Move to the next word.
movb #'B, @#tpb
pwait:
tstb @#tps ;Busy wait, wait till end of print.
bpl pwait
add #2, r0
dec r2
br Ploop
printWH:
movb #'W, @#tpb
p1wait:
tstb @#tps ;Busy wait, wait till end of print.
bpl p1wait
add #2, r0
dec r2
br Ploop
print_:
movb #'_, @#tpb
p2wait:
tstb @#tps ;Busy wait, wait till end of print.
bpl p2wait
add #2, r0
dec r2
br Ploop
endP:
jsr pc, printNL ; Printing new line
jsr pc, printNL ; Printing new line
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;-------------------------------------------------------------------------------
;                                initBoard
;-------------------------------------------------------------------------------

initBoard:
mov r0, -(sp) ; Backing up r0.
mov r1, -(sp) ; Backing up r1.
mov r2, -(sp) ; Backing up r2.
mov #Board, r1
add #128., r1
mov #Board, r0
mov #NewBoard, r2
Cpyloop:
cmp r0, r1
beq endCpy
mov (r2)+, (r0)+
br Cpyloop
endCpy:
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0
rts pc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;















;-------------------------------------------------------------------------------
;                                 getMaxWP:
;-------------------------------------------------------------------------------
; This function makes first preperations and calls the reccursive function.
; Inputs:
;   1. #SrcPos - Label to write the source position of the piece should move.
;   2. #DstPos - Label to write the destenation position of the piece should move.
;   3. #WinParam - Label to write the winning parameter.
; A label of the board, number of steps (how deep to check) and the player to
; check will also be inputs in a common area.
; Outputs:
; The outputs will be written to the given labels (inputs).
;-------------------------------------------------------------------------------
getMaxWP:
; Preparing the stack for the first call.
mov #0, -(sp) ; Allocating place source position in stack.
mov #0, -(sp) ; Allocating place destenation position in stack.
mov #-100., -(sp) ; Allocating place for WP in stack.
mov #1, -(sp) ;  Allocating place for minOrMax of the first player.
mov turn, -(sp) ; Pushing the player we check to the stack.
mov Steps, -(sp) ; Pushing number of steps to stack.
; Calling the recursive function.
jsr pc, getWPRec ;
tst gameOn
beq CpuTup
tst TIMOUT
bne CpuTup
; Computer player still has time.
; Recursive function finished
; Popping unnecessary data from stack and writing output to given labels:
add #6, sp ; Popping unnecessary data from stack.
mov (sp)+, @6.(sp) ; Writing the best wp to WP label.
; SrcPos and DstPos returned as address of the board.
mov (sp)+, @6.(sp) ; Writing adress to DstPos
mov (sp)+, @6.(sp) ; Writing adress to SrcPos
add #2, Steps
jmp getMaxWP
CpuTup:
add #12., sp
rts pc ; Returning to main.

;-------------------------------------------------------------------------------
;                                 getWPRec:
;-------------------------------------------------------------------------------
; This function is the recursive function. It calculates the best next move of a
; given player in a given board.
; Inputs:
;   1. Player to check - will be in a common area.
;   2. Steps - number of steps left to check.
;   3.
;-------------------------------------------------------------------------------
; This is the reccursive function.
getWPRec:
; ----- STOP TERMS -----
tst gameOn
bne keepon
rts pc
keepon:
tst TIMOUT
beq keepcalc
rts pc
keepcalc:
; Preparing to call for checkWin with the last player to make a move:
mov #Board, -(sp) ; Moving board adress to stack.
; Pushing the last player to make a move to stack.
; The current player has changed before calling the rec function, therefore
; we switch to the other player (black + white - current_player):
mov #3, -(sp)
sub 8.(sp), (sp)
mov #0, -(sp) ; Allocating space for output of checkWin.
; Checks if the last player to make a move won:
jsr pc, checkWin
cmp #1, (sp)+ ; Checking the output and pops it from stack.
beq whoWon ; Jumps if he won.

; Last player didn't win. Now we'll check if the current player won:
mov 8.(sp), (sp) ; Moving current player to the top of the stack.
mov #0, -(sp) ; Allocating space for output of checkWin.
jsr pc, checkWin
cmp #1, (sp)+ ; Checking the output and pops it from stack.
beq whoWon ; Jumps if he won.

; If we got here no one won.
add #4, sp ; Pop the other player and board from the stack.
tst 2(sp) ; Check if the current number of steps is 0.
bne jchkMov ; Jumps if (steps > 0)

; If we got here steps is 0.
mov #Board, -(sp) ; Moving board adress to stack.
mov turn, -(sp) ; Moving the player we check to the top of the stack.
jsr pc, calcWP ; Output will be at r4.
add #4, sp ; Popping the no longer needed inputs (board and player).
mov r4, 8.(sp) ; Copying output from r4 to caller's wp.
rts pc

jchkMov:
; Checking if the current player has legal moves to make:
mov 4(sp), -(sp) ; Moving current player to the top of the stack.
mov #0, -(sp) ; Allocating a place for output.
jsr pc, hasMove
mov (sp)+, (sp) ; Writing the output of hasMove instead of current player (override).
tst (sp)+  ; Checks if number of legal moves of current player is 0 and pops it.
bne chkMoves ; Jumps if he has moves to make.
; If we got here the current player has no legal moves and we need to skip his turn.
; Preparing to call next iteration:
mov #0, -(sp) ; Allocating space for SrcPos.
mov #0, -(sp) ; Allocating space for DstPos.
cmp 10.(sp), #1 ; Checks what the caller function (father) was looking for.
bne putMax ; Jumps if the father was looking for minimum.
; Father was looking for maximum. Now we should put minimum:
mov #100., -(sp) ; Pushing wp. WP = MAX_VALUE
mov #-1., -(sp) ; Pushing -1. This means that we are looking for minimum now.
jmp cont ; Done changing max->min.

putMax:
; Father was looking for minimum. Now we should put maximum:
mov #-100., -(sp) ; Pushing wp. WP = MIN_VALUE
mov #1., -(sp) ; Pushing -1. This means that we are looking for maximum now.

cont:
; Continues the preperations.
; Switch players:
mov #3., -(sp)
sub 14.(sp), (sp)
; Reducing steps by 1:
mov 12.(sp), -(sp)
sub #1., (sp)
jsr pc, getWPRec
; Checking if it is the first move. If yes, we will handle it seperatly.
add #1, (sp) ; Adding 1 to current steps because we reduced it by 1 before.
cmp (sp), Steps ; Checking if current steps is the global steps (aka first move).
beq firstMov ; if current steps = global steps - go to firstMov to handle it.
sub #1, (sp) ; Restoring steps to what it was before the cmp.

; Checking the returned values and updating if needed:
cmp #1., 18.(sp) ; Checks what the caller function (father) was looking for.
beq wasMax ; Jumps if the father was looking for maximum.
; Father was looking for minimum. Checks if we need to update WP to the new WP.
cmp 6.(sp), 20.(sp) ; Comparing WPs.
bgt noUp ; Jumps if we don't need to update.
; If we got here we need to update:
mov 6.(sp), 20.(sp) ; Updating father's wp.
mov 8.(sp), 22.(sp) ; Updating father's DstPos.
mov 10.(sp), 24.(sp) ; Updating father's SrcPos.
add #12., sp ; Popping unnecessary data from stack.
rts pc

wasMax:
; Father was looking for maximum. Checks if we need to update WP to the new WP.
cmp 6.(sp), 20.(sp) ; Comparing WPs.
ble noUp ; Jumps if we don't need to update.
; If we got here we need to update:
mov 6.(sp), 20.(sp) ; Updating father's wp.
mov 8.(sp), 22.(sp) ; Updating father's DstPos.
mov 10.(sp), 24.(sp) ; Updating father's SrcPos.
add #12., sp ; Popping unnecessary data from stack.
rts pc

firstMov:
; If we got here then in the first move the player we check cannot move. therefore
; we need to find any piece of his and update the src and dst to the location of
; that piece.
sub #1, (sp) ; Restoring steps to what it was before the cmp after jsr.
mov #Board, -(sp) ; will be used to scan for a piece.
fPiece:
cmp @(sp), turn
beq pieceF ; Piece found - go to update src and dst.
add #2, (sp) ; Continue checking in the next cell.
br fPiece
pieceF:
mov 8.(sp), 22.(sp) ; Updating father's wp.
mov (sp), 24.(sp) ; Updating father's DstPos.
mov (sp)+, 24.(sp) ; Updating father's SrcPos.
noUp:
; If we got here we do not need to update.
add #12., sp ; Popping unnecessary data from stack.
rts pc

whoWon:
cmp 6(sp), Steps
bne goOn
; This code will update Src and Dst in situations of instant win, meaning the
; given board is already in a state of win.
mov #Board, -(sp)
fwinPiece: ; finding any piece of the winner.(reminder: this is an instant win)
cmp @(sp), turn
beq pFound ; Piece Found
add #2, (sp)
br fwinPiece
pFound:
mov (sp), 16.(sp) ; Updating father's DstPos.
mov (sp)+, 16.(sp) ; Updating father's SrcPos.


goOn:
; Checks who won.
cmp (sp)+, turn ; Check if the current player is the one we check.
bne playerLos ; Jumps if the winner is not who we check.
; The winner is the player we check. Updating WP to 20:
mov #20, 10.(sp) ; WP = 20.
tst (sp)+ ; Popping the no longer needed board from stack.
rts pc
playerLos:
;The winner is not the player we check. Updating WP to -20:
mov #-20, 10.(sp) ; WP = -20.
tst (sp)+ ; Popping the no longer needed board from stack.
rts pc
; --- END OF STOP TERMS ---

; r0 - Current row index.
; r1 - Current column index.
chkMoves:
clr r0 ; Sets r0 to 0.
clr r1 ; Sets r1 to 0.
cmp 4(sp), #1 ; Checking if the current color is white.
bne jBlack ; If the color is not white, branch to Black.
jmp White ; If the color is white, branch to White.

jBlack:
  jmp Black

; This method will check legal moves of all white pieces and calls the reccursive
; function each time a legal move is found.
; r2 - Will store the current checked cell address.
; r3 - temporary row index (will be used once for another calculation).
; r5 - temporary column index (will be used once for another calculation).
White:
mov r0, r3  ; Putting index of the current row in r3.
mov r1, r5  ; Putting index of the current column in r5.
mov #Board, r2 ; Putting board array starting index in r2.
mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bytes).
mul #2, r5 ; Multiplying the number of column by 2 (decimal) (width of each column in bytes).
add r3, r2 ; Adding the number of bytes needed in order to point to the beginning of a row.
add r5, r2 ; Adding the number of bytes needed in order to point a cell in a row.
; r2 will now contain the address of the current cell.
cmp (r2), #1 ; Checking if the current piece is white.
bne NextCell ; If the color of the current piece is not white skip to the next cell.
mov r0, r3 ; Setting r3 to the current row index (after changing it earlier).
sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt NextCell ; If row index is less than 0, cannot move at all, skip to the next cell.
mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
add #1, r5 ; Increasing column index by 1.
cmp r5, #7
bgt LeftW ; If column index is bigger than 7, the current piece cannot move right, check legal moves to the left.
cmp -14.(r2), #1 ; Checking if the upper right piece is white.
beq LeftW ; If the upper right piece is white, cannot go there, check legal moves to the left.
cmp -14.(r2), #2 ; Checking if the upper right piece is black.
beq EatRW ; If the upper right piece is black, check if the white piece can eat it.

; --- WHITE CAN MOVE RIGHT ---
; Current white piece can move to the right.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
sub #14., (sp)
; No eaten piece. Inserting 0:
mov #0, -(sp)
; Makes the move:
jsr pc, WhiteMov
add #4., sp ; Popping unnecessary data from stack.
jmp LeftW ; Go to check if this piece can also move to the left.

; --- WHITE EAT RIGHT ---
; Checks if white piece can eat to the right.
EatRW:
sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt LeftW ; If r3 is less than 0, cannot eat (out of bounds). Check legal moves to the left.
add #1, r5 ;Increasing column index by 1.
cmp r5, #7
bgt LeftW ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the left.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, we need to check if it is empty.
cmp -28.(r2), #0 ; Checking if the cell is empty.
bne LeftW ; If the cell is not empty, cannot eat. Check legal moves to the left.

; --- WHITE CAN EAT RIGHT ---
; Current white piece can eat to the right.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
sub #28., (sp)
; Inserting location of eaten piece.
mov r2, -(sp)
sub #14., (sp)
; Makes the move:
jsr pc, WhiteMov
add #4., sp ; Popping unnecessary data from stack.
jmp LeftW ; Go to check if this piece can also move to the left.

; --- WHITE MOVE LEFT ---
; Checks if white piece can move left.
LeftW:
mov r0, r3 ; Putting index of the current row in r3.
sub #1, r3 ; Reducing row index by 1.
mov r1, r5 ; Putting index of the current column in r5.
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt NextCell ; If column index is less than 0, cannot move right, skip to the next cell.
cmp -18.(r2), #1 ; Checking if the upper left piece is white.
beq NextCell ; If the upper left piece is white, cannot move there, skip to the next cell.
cmp -18.(r2), #2 ; Checking if the upper left piece is black.
beq EatLW ; If the upper left piece is black, Check if the white piece can eat it.

; --- WHITE CAN MOVE LEFT ---
; Current white piece can move to the left.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
sub #18., (sp)
; No eat. Inserting 0:
mov #0., -(sp)
; Makes the move:
jsr pc, WhiteMov
add #4., sp
jmp NextCell ; Current white piece cannot move anymore. Go to check next cell.

; --- WHITE EAT LEFT ---
; Checks if white piece can eat to the left.
EatLW:
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt NextCell ; If column index is less than 0, cannot eat, skip to the next cell.
sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt NextCell ; If r3 is less than 0, cannot eat (out of bounds). Skip to the next cell.
;If we got here, the cell which the current white piece should be
;placed in after eating is in the board bounds, Check if it is empty.
cmp -36.(r2), #0 ; Checking if the cell is empty.
bne NextCell ;If the cell is not empty, cannot eat. Skip to the next cell.

; --- WHITE CAN EAT LEFT ---
; Current white piece can eat to the left.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
sub #36., (sp)
; Inserting location of eaten piece:
mov r2, -(sp)
sub #18., (sp)
; Makes the move:
jsr pc, WhiteMov
add #4., sp ; Popping unnecessary data from stack.
jmp NextCell ; Current white piece cannot move anymore. Go to check next cell.

End: ;If we got here we checked all the cells of the array.
rts pc

; This method will skip to the next cell by adding 1 to column index. If column
; index is bigger than 7 sets it to 0 and adds 1 to row index.
; r0 - Current row index.
; r1 - Current column index.
NextCell:
add #1, r1 ; Increasing column index by 1.
cmp r1, #8 ; Checking if reached the end of the row.
blt InRange ; Branch to InRange if the index of column is legal.
clr r1 ; If we got here index of column reached the end of row. Sets it to 0.
add #1, r0 ; Go to the next row.
cmp r0, #7
bgt End ; If index of row is bigger than 7 we reached the end of the board.

;Continues to the next cell once its indexes are valid.
InRange:
cmp 4(sp), #1
bne Black
jmp White

jNxtCell:
  jmp NextCell

; This method will check legal moves of all black pieces and calls the reccursive
; function each time a legal move is found.
; r2 - Will store the current checked cell address.
; r3 - temporary row index (will be used once for another calculation).
; r5 - temporary column index (will be used once for another calculation).
Black:
mov r0, r3  ; Putting index of the current row in r3.
mov r1, r5  ; Putting index of the current column in r5.
mov #Board, r2 ; Putting board array starting index in r2.
mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bytes).
mul #2, r5 ; Multiplying the number of column by 2 (decimal) (width of each column in bytes).
add r3, r2 ;Adding the number of bytes needed in order to point to the beginning of a row.
add r5, r2 ; Adding the number of bytes needed in order to point a cell in a row.
; r2 will now contain the address of the current cell.
cmp (r2), #2 ; Checking if the current piece is black.
bne NextCell ; If the color of the current piece is not black skip to the next cell.
mov r0, r3 ; Putting index of the current row in r3.
add #1, r3 ; Increasing row index by 1.
cmp r3, #7
bgt NextCell ; If row index is bigger than 7, cannot move at all, skip to the next cell.
mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
add #1, r5 ; Increasing column index by 1.
cmp r5, #7
bgt RightB ; If column index is bigger than 7, the current piece cannot move left, Check legal moves to the right.
cmp 18.(r2), #2 ; Checking if the lower right piece is black.
beq RightB ; If the lower left piece is black, cannot go there, Check legal moves to the right.
cmp 18.(r2), #1 ; Checking if the lower right piece is black.
beq EatLB ; If the lower right piece is white, check if the black piece can eat it.


; --- BLACK CAN MOVE LEFT ---
; Current black piece can move to the left.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
add #18., (sp)
; No eaten piece. Inserting 0:
mov #0, -(sp)
; Makes the move:
jsr pc, BlackMov
add #4., sp ; Popping unnecessary data from stack.
jmp RightB ; Go to check if current black piece can move to the right.

; --- BLACK EAT LEFT ---
; Checks if black piece can eat to the left.
EatLB:
add #1, r3 ; Increasing row index by 1.
cmp r3, #7 ; If r3 is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
bgt RightB
add #1, r5 ;Increasing column index by 1.
cmp r5, #7
bgt RightB ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
;If we got here, the cell which the current black piece should be placed after eating is in the board bounds, we need to check if it is empty.
cmp 36.(r2), #0 ; Checking if the cell is empty.
bne RightB ; If the cell is not empty, cannot eat. Check legal moves to the right.

; --- BLACK CAN EAT LEFT ---
; Current black piece can move to the left.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
add #36., (sp)
; Inserting location of eaten piece:
mov r2, -(sp)
add #18., (sp)
; Makes the move:
jsr pc, BlackMov
add #4., sp ; Popping unnecessary data from stack.
jmp RightB

; --- BLACK MOVE RIGHT ---
; Checking if black piece can move right.
RightB:
mov r0, r3 ; Putting index of the current row in r3.
add #1, r3 ; Increasing row index by 1.
mov r1, r5 ; Putting index of the current column in r5.
sub #1, r5 ; Decreasing column index by 1.
cmp r5, #0
blt NextCell ; If column index is less than 0, cannot move right, skip to the next cell.
cmp 14.(r2), #2 ; Checking if the lower left piece is black.
beq NextCell ; If the lower left piece is white, cannot move there, skip to the next cell.
cmp 14.(r2), #1 ; Checking if the lower left piece is white.
beq EatRB ; If the lower left piece is white, check if the black piece can eat it.

; --- BLACK CAN MOVE RIGHT ---
; Current black piece can move to the right.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
add #14., (sp)
; No eaten piece. Inserting 0:
mov #0, -(sp)
; Makes the move:
jsr pc, BlackMov
add #4., sp ; Popping unnecessary data from stack.
jmp NextCell ; Current black piece cannot move anymore. Go to next cell.

EatRB:
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt NextCell ; If column index is less than 0, cannot eat, skip to the next cell.
add #1, r3 ; Increasing row index by 1.
cmp r3, #7
bgt NextCell ; If r3 is bigger than 7, cannot eat (out of bounds). Skip to the next cell.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
cmp 28.(r2), #0 ; Checking if the cell is empty.
bne jNxtCell ;If the cell is not empty, cannot eat. Skip to the next cell.

; --- BLACK CAN EAT RIGHT ---
; Current black piece can eat to the right.
; Preparing for the Call:
; Inserting new location of the white piece to stack:
mov r2, -(sp)
add #28., (sp)
; Inserting location of eaten piece:
mov r2, -(sp)
add #14., (sp)
; Makes the move:
jsr pc, BlackMov
add #4., sp ; Popping unnecessary data from stack.
jmp NextCell ; Current black piece cannot move anymore. Go to next cell.


; This method checks if a given board is in a winning state for the given player.
; Input:
; 1. A number of player to check - will be stored in 4(sp).
; 2. A label of the beginning of the board - will be stored in 6(sp).
; Output:
; -1 if the current player didn't win, 1 if the current player wins - will be stored in 2(sp).
checkWin:
tst -(sp) ; Allocating place for number of white pieces (output of countWB).
tst -(sp) ; Allocating place for number of black pieces (output of countWB).
mov 12(sp), -(sp) ; Copying board adress to the top of the stack.
jsr pc, countWB ; Counting number of pieces from each color and puts it in stack.
tst (sp)+ ; Pop board adress.
cmp 10(sp), #1 ; Check if the current player is white.
bne checkb ; Branch to checkb if the current player is black.
tst (sp) ; Current player is white, checks the number of black pieces.
beq currWin ; If the number of black pieces is 0 white player wins.
tst 2(sp) ; Checks the number of white pieces.
beq noWin ; Current player is white and the number of white pieces is 0, white player loses.
br not0 ; Both player's number of pieces is not 0.

checkb: ; The current player is black.
tst 2(sp) ; Checks if the number of white pieces is 0.
beq currWin ; Black player wins.
tst (sp) ; Checks if the number of black pieces is 0.
beq noWin ; Current player is black and the number of black pieces is 0.

not0: ; We get here if the number of both player's pieces is not 0.
mov #1, -(sp) ; Moving number of white player to check number of moves for him.
mov #0, -(sp) ; Allocating place for number of moves and setting it to 0.
; Checking if there is legal moves for the given player.
jsr pc, hasMove ; Number of legal moves for white player will be at the top of the stack.
tst (sp) ; Checks if white player has legal moves to make.
bne hasMoves ; There are still moves to make.
mov #2, 2(sp) ; Moving number of black player to check number of moves for him.
jsr pc, hasMove ; Number of legal moves for black player will be at the top of the stack.
tst (sp) ; Checks if both players has legal moves to make.
bne hasMoves ; One of the players still has moves to make.
tst (sp)+ ; Pops number of player's moves.
tst (sp)+ ; Pops player number.
cmp #1, 10(sp) ; Checks if the player is the white player.
bne blackChk ; The player is the black player.
cmp 2(sp), (sp) ; Checks if number of white pieces is bigger than number of black pieces.
bgt currWin ; If the number of white pieces is bigger, white player wins.
br noWin ; If we got here the number of white pieces is not bigger.
blackChk: ; The current player color is black.
cmp (sp), 2(sp) ; Checks if number of black pieces is bigger than number of white pieces.
bgt currWin ; Black player wins.
br noWin ; Black player lost.

currWin: ; The current player wins.
tst (sp)+ ; Pop number of black pieces.
tst (sp)+ ; Pop number of white pieces.
mov #1, 2(sp) ; The return value will be 1.
rts pc

hasMoves: ; One of the players still has legal moves.
tst (sp)+ ; Pops number of moves.
tst (sp)+ ; Pops the number of player.
noWin: ; The current player is not winning.
tst (sp)+ ; Pop number of black pieces.
tst (sp)+ ; Pop number of white pieces.
mov #-1., 2(sp)
rts pc
; END OF checkWin

; This method will calculate the winning parameter of a given board.
; Input:
; 1. Label of the current board status - will be stored at 4(sp).
; 2. Current player's turn (1-white,2-black) - will be stored at 2(sp).
; Output:
; Winning parameter - will be stored at R4.
calcWP:
mov 0, -(sp) ; Leaving blank space for output of countWB.
mov 0, -(sp) ; Leaving blank space for output of countWB.
mov 8(sp), -(sp) ; Giving the label of the board as input.
jsr pc, countWB ; Counting number of pieces from each color.
add #2, sp ; Popping the no longer needed board label from stack.
cmp 6(sp), #2
beq WPforW ; if current player (input) is black - go to WPforW
; If we got here then the current player is black. It means that
; the last player to move was white.
mov 2(sp), r4 ; r4 = number of white vessels.
sub (sp), r4 ; r4 = r4 - number of black vessels.
br endCalWP ; Jumping to the end of the method.
WPforW:
; If we got here current player is white. It means that the
; last player to move was black.
mov (sp), r4 ; r4 = number of black vessels.
sub 2(sp), r4 ; r4 = r4 - number of white players.
br endCalWP ; Jumping to the end of the method.
endCalWP:
add #4, sp ; popping 2 items from stack (counters of W&B pieces)
rts pc
; END OF calcWP

; ------------------------- HELPING FUNCTIONS -------------------------
; 1. WhiteMov - Making a move for white piece and calls the recursive function.
; 2. Blackmov - Making a move for black piece and calls the recursive function.
; 3. countWB - Counting number of pieces from each color.
; 4. hasMove - Counting the legal moves of a given player in a given board.
;----------------------------------------------------------------------

; This method will do the moving of a white piece and calls the reccursive function.
; Input:
; 1. Address of piece to move.
; 2. Address of eaten piece. If it is not an eat the value will be 0.
WhiteMov:
; Making the move of the white player:
mov #1, @4.(sp) ; Moving white piece to the new place.
mov #0, (r2) ; Removing white piece from the last place it was.

; Checks if there is an eat
tst 2(sp)
beq noEat

; If we got here there is an eat
mov #0, @2.(sp) ; Removing eaten piece

noEat:
; Backing up registers before calling the REC function.
mov r0, -(sp) ; Backing up r0.
mov r1, -(sp) ; Backing up r1.
mov r2, -(sp) ; Backing up r2.
mov r3, -(sp) ; Backing up r3.
mov r5, -(sp) ; Backing up r5.

; Preparing the arguments for the REC function.
mov #0, -(sp) ; Allocating source position.
mov #0, -(sp) ; Allocating destenation position.
cmp #1, 26.(sp) ; Checking if minimum or maximum was checked in the last call.
beq chngMin ; Changing maximum to minimum.

; If we got here in the next REC we will check for maximum
mov #-100., -(sp) ; Miminum was checked in the last call.
mov #1, -(sp) ; Maximum will be checked.
br changed

chngMin: ; Changing maximum to minimum.
mov #100., -(sp) ; Maximum was checked in the last call.
mov #-1., -(sp) ; Minimum will be checked.

changed: ; Changed maximum\minimum value.
mov #3, -(sp)
sub 30.(sp), (sp) ; Chaning to the other player.
mov 28.(sp), -(sp) ; Copying last number of steps.
sub #1, (sp) ; Substract 1 from number of steps.
jsr pc, getWPRec

cmp 34.(sp), #1 ; The father is looking for a maximum.
beq upMax ; Father was looking for a maximum.

; Father was looking for a minimum.
cmp 6.(sp), 36.(sp) ; Comparing wp to the wp of the father.
bgt nUpdate

; Updating minimum.
mov 6(sp), 36.(sp) ; Updating father wp to new minimum.
add #12., sp ; Popping all values besides registers backup.
mov (sp)+, r5
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0

; Restoring previous board and updating father src and dst.
; Restoring white piece previous location.
mov #1, (r2)
mov #0, @4.(sp)
; Checks if there was an eat:
tst 2(sp) ;
beq SrcDst ; No eat. We don't need to restore. go to update src and dst.
; If we got here there was an eat and we need to restore it.
mov #2., @2.(sp) ; Restoring eaten black piece.
br SrcDst

SrcDst:
mov r2, 18.(sp) ; Updating father's SrcPos.
mov 4(sp), 16.(sp) ; Updating father's DstPos.
rts pc

nSrcDst:
rts pc

upMax:
; The father is looking for maximum
cmp 6(sp), 36.(sp) ; Comparing wp to the wp of the father.
ble nUpdate ; Jumps if we do not need to update.

; We need to update to new Maximum
mov 6(sp), 36.(sp) ; Updating father wp to new maximum.
add #12., sp ; Popping all values besides registers backup.
mov (sp)+, r5
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0

; Restoring previous board and updating father src and dst.
; Restoring white piece previous location.
mov #1, (r2)
mov #0, @4.(sp)
; Checks if there was an eat:
tst 2(sp) ;
beq SrcDst ; No eat. We don't need to restore. go to update src and dst.
; If we got here there was an eat and we need to restore it.
mov #2., @2.(sp) ; Restoring eaten black piece.
br SrcDst

nUpdate:
add #12., sp ; Popping all values besides registers backup.
mov (sp)+, r5
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0
; Restoring previous board and updating father src and dst.
; Restoring white piece previous location.
mov #1, (r2)
mov #0, @4.(sp)
; Checks if there was an eat:
tst 2(sp) ;
beq nSrcDst ; No eat. We don't need to restore. No need to update src and dst.
mov #2., @2.(sp) ; Restoring eaten black piece.
br nSrcDst ; No need to update src and dst.
; END OF WhiteMov

; This method will do the moving of a black piece and calls the reccursive function.
; Input:
; 1. Address of piece to move.
; 2. Address of eaten piece. If it is not an eat the value will be 0.
BlackMov:
; Making the move of the black player.
mov #2, @4.(sp) ; Moving black piece to the new place.
mov #0, (r2) ; Removing black piece from the last place it was.

; Checks if there is an eat
tst 2(sp)
beq noEatB

; If we got here there is an eat
mov #0, @2.(sp) ; Removing eaten piece

noEatB:
; Backing up registers before calling the REC function.
mov r0, -(sp) ; Backing up r0.
mov r1, -(sp) ; Backing up r1.
mov r2, -(sp) ; Backing up r2.
mov r3, -(sp) ; Backing up r3.
mov r5, -(sp) ; Backing up r5.

; Preparing the arguments for the REC function.
mov #0, -(sp) ; Allocating source position.
mov #0, -(sp) ; Allocating destenation position.
cmp #1, 26.(sp) ; Checking if minimum or maximum was checked in the last call.
beq chngMinB ; Changing maximum to minimum.

; If we got here in the next REC we will check for maximum
mov #-100., -(sp) ; Miminum was checked in the last call.
mov #1, -(sp) ; Maximum will be checked.
br changedB

chngMinB: ; Changing maximum to minimum.
mov #100., -(sp) ; Maximum was checked in the last call.
mov #-1., -(sp) ; Minimum will be checked.

changedB: ; Changed maximum\minimum value.
mov #3, -(sp)
sub 30.(sp), (sp) ; Changing to the other player.
mov 28.(sp), -(sp) ; Copying last number of steps.
sub #1, (sp) ; Substract 1 from number of steps.
jsr pc, getWPRec

cmp 34.(sp), #1 ; The father is looking for a maximum.
beq upMaxB ; Father was looking for a maximum.

; Father was looking for a minimum.
cmp 6(sp), 36.(sp) ; Comparing wp to the wp of the father.
bgt nUpdateB

; Updating minimum.
mov 6(sp), 36.(sp) ; Updating father wp to new minimum.
add #12., sp ; Popping all values besides registers backup.
mov (sp)+, r5
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0

; Restoring previous board and updating father src and dst.
; Restoring black piece previous location.
mov #2, (r2)
mov #0, @4.(sp)
; Checks if there was an eat:
tst 2(sp) ;
beq SrcDstB ; No eat. We don't need to restore. go to update src and dst.
; If we got here there was an eat and we need to restore it.
mov #1., @2.(sp) ; Restoring eaten white piece.
br SrcDstB

SrcDstB:
mov r2, 18.(sp) ; Updating father's SrcPos.
mov 4(sp), 16.(sp) ; Updating father's DstPos.
rts pc

nSrcDstB:
rts pc

upMaxB:
; The father is looking for maximum
cmp 6(sp), 36.(sp) ; Comparing wp to the wp of the father.
ble nUpdateB ; Jumps if we do not need to update.

; We need to update to new Maximum
mov 6(sp), 36.(sp) ; Updating father wp to new maximum.
add #12., sp ; Popping all values besides registers backup.
mov (sp)+, r5
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0

; Restoring previous board and updating father src and dst.
; Restoring black piece previous location.
mov #2, (r2)
mov #0, @4.(sp)
; Checks if there was an eat:
tst 2(sp) ;
beq SrcDstB ; No eat. We don't need to restore. go to update src and dst.
; If we got here there was an eat and we need to restore it.
mov #1., @2.(sp) ; Restoring eaten white piece.
br SrcDstB

nUpdateB:
add #12., sp ; Popping all values besides registers backup.
mov (sp)+, r5
mov (sp)+, r3
mov (sp)+, r2
mov (sp)+, r1
mov (sp)+, r0
; Restoring previous board and updating father src and dst.
; Restoring black piece previous location.
mov #2, (r2)
mov #0, @4.(sp)
; Checks if there was an eat:
tst 2(sp) ;
beq nSrcDstB ; No eat. We don't need to restore. No need to update src and dst.
mov #1., @2.(sp) ; Restoring eaten white piece.
br nSrcDstB ; No need to update src and dst.
; END OF BlackMov


; This method will count how many vessles from each color are there on the
; given board.
; Input:
; Label of the beginning of the board - will be stored at 2(sp).
; Output:
; Number of white vessels - after rts will be stored at 4(sp).
; Number of black vessels - after rts will be stored at 2(sp).
;
; Notice: after rts 0(sp) will store the label of the board.
countWB:
mov r0, -(sp) ; Backing up r0. r0 will be used to scan the board.
mov r1, -(sp) ; Backing up r1. r1 will be used to count white vessels.
mov r2, -(sp) ; Backing up r2. r2 will be used to count black vessels.
mov r3, -(sp) ; Backing up r3. r3 will store the end of the board.
clr r1
clr r2
mov 10.(sp), r0 ; r0 = beginning of the board.
mov r0, r3 ; r3 = beginning of the board.
add #176, r3 ; r3 = end of the board.
cntloop:
tst (r0) ;
beq endloop ; if (r0) is 0 then no player in this cell.
cmp (r0), #1
bne addBLK
inc r1 ; Current cell is white. r1++ .
br endloop ; Go to next cell.
addBLK:
inc r2 ; Current cell is black. r2++ .
jmp endloop ; Go to next cell.

endloop:
add #2, r0 ; r0 will point to next cell in the board.
cmp r0,r3
ble cntloop ; if we are still in the board limits - go to cntloop.
; If we got here we finished going through the entire board.
mov r1, 14.(sp) ; Writing white counter to stack.
mov r2, 12.(sp) ; Writing black counter to stack.
mov (sp)+, r3 ; Restoring the value of r3.
mov (sp)+, r2 ; Restoring the value of r2.
mov (sp)+, r1 ; Restoring the value of r1.
mov (sp)+, r0 ; Restoring the value of r0.
rts pc
; END OF countWB

; This method checks the given player has at least one legal move.
; Input:
; A number of player to check, will be at 2(sp).
; Output:
; A number of moves to add to, will be at (sp).
hasMove:
; r0 - Current row index.
; r1 - Current column index.
mov r0, -(sp) ; Saving r0's value on stack.
mov r1, -(sp) ; Saving r1's value on stack.
mov r2, -(sp) ; Saving r2's value on stack
mov r3, -(sp) ; Saving r3's value on stack
mov r5, -(sp); Saving r5's value on stack
clr r0 ; Sets r0 to 0.
clr r1 ; Sets r1 to 0.
cmp 14.(sp), #1 ; Checking if the current color is white.
bne chkBlack ; If the color is not white, branch to Black.
br chkWhite ; If the color is white, branch to White.

chkWhite:
; This method will check legal moves of all white pieces.
; r2- current cell pointer.
; r3 - temporary row index (will be used once for another calculation).
; r5 - temporary column index (will be used once for another calculation).

mov r0, r3  ; Putting index of the current row in r3.
mov r1, r5  ; Putting index of the current column in r5.
mov #Board, r2 ; Putting board array starting index in r2.
mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bits).
mul #2, r5 ; Multiplying the number of column by 2 (decimal) (length of each column in bits).
add r3, r2 ; Adding the number of bits needed in order to point to a start of a row.
add r5, r2 ; Adding the number of bits needed in order to point a cell in a row.
; r2 will now contain the address of the current cell.
cmp (r2), #1 ; Checking if the current piece is white.
bne SkipCell ; If the color of the current piece is not white skip to the next cell.
mov r0, r3 ; Setting r3 to the current row index (after changing it earlier).
sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt SkipCell ; If row index is less than 0, cannot move left or right, skip to the next cell.
mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
add #1, r5 ; Increasing column index by 1.
cmp r5, #7
bgt jLeftW01 ; If column index is bigger than 7, the current piece cannot move right, check legal moves to the left.
cmp -14.(r2), #1 ; Checking if the upper right piece is white.
beq jLeftW01 ; If the upper right piece is white, cannot go there, check legal moves to the left.
cmp -14.(r2), #2 ; Checking if the upper right piece is black.
beq eatrw1 ; If the upper right piece is black, check if the white piece can eat it.
add #1, 12.(sp) ; If we got here the upper right cell contains 0, the white piece can move there. Adding 1 to number of legal moves.
br canMove ;Found a legal move.


eatrw1:
;This method will check an eating option the right of white pieces.
; r2- current cell pointer.
; r3 - temporary row index .
; r5 - temporary column index.

sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt jLeftW01 ; If r3 is less than 0, cannot eat (out of bounds). Check legal moves to the left.
add #1, r5 ;Increasing column index by 1.
cmp r5, #7
bgt jLeftW01 ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the left.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, we need to check if it is empty.
cmp -28.(r2), #0 ; Checking if the cell is empty.
bne jLeftW01 ; If the cell is not empty, cannot eat. Check legal moves to the left.
add #1, 12.(sp) ;If we got here, can eat, adding 1 to number of legal moves.
br canMove ;Found a legal move.

jLeftW01:
; This method will check legal moves to the left of white pieces.
; r2- current cell pointer.
; r3 - temporary row index .
; r5 - temporary column index.

mov r0, r3 ; Putting index of the current row in r3.
sub #1, r3 ; Reducing row index by 1.
mov r1, r5 ; Putting index of the current column in r5.
sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt SkipCell ; If column index is less than 0, cannot move right, skip to the next cell.
cmp -18.(r2), #1 ; Checking if the upper left piece is white.
beq SkipCell ; If the upper left piece is white, cannot move there, skip to the next cell.
cmp -18.(r2), #2 ; Checking if the upper left piece is black.
beq eatlw1 ; If the upper left piece is black, Check if the white piece can eat it.
add #1, 12.(sp) ; If we got here, upper left cell contains 0, can move there. Adding 1 to number of legal moves..
br canMove ;Found a legal move.

eatlw1:
;This method will check an eating option the left of white pieces.
; r2- current cell pointer.
; r3 - temporary row index .
; r5 - temporary column index.

sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt SkipCell ; If column index is less than 0, cannot eat, skip to the next cell.
sub #1, r3 ; Reducing row index by 1.
cmp r3, #0
blt SkipCell ; If r3 is less than 0, cannot eat (out of bounds). Skip to the next cell.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
cmp -36.(r2), #0 ; Checking if the cell is empty.
bne SkipCell ;If the cell is not empty, cannot eat. Skip to the next cell.
add #1, 12.(sp) ;If we got here, can eat, adding 1 to legal number of moves on the stack.
br canMove ;Found a legal move.

canMove: ;If we got here we checked all the cells of the array or we got a legal move.
mov (sp)+, r5 ; Returning r5 it's original value.
mov (sp)+, r3 ; Returning r3 it's original value.
mov (sp)+, r2 ; Returning r2 it's original value.
mov (sp)+, r1 ; Returning r1 it's original value.
mov (sp)+, r0 ; Returning r0 it's original value.
rts pc ; When we return from this subroutine the output will be at the top of the stack

SkipCell:
; This method will skip to the next cell by adding 1 to column index. If column
; index is bigger than 7 sets it to 0 and adds 1 to row index.
; r0 - Current row index.
; r1 - Current column index.

add #1, r1
cmp r1, #8 ; Checking if passed end of row.
blt RangeOK ; Index of column is legal.
clr r1 ; If we got here index of column passed end of row. Set it to 0.
add #1, r0 ; Go to the next row.
cmp r0, #7
bgt canMove ; If index of row is bigger than 7 we reached the end of the board.

RangeOK:
;Continue on checking in the same row.
cmp 14.(sp), #1
bne chkBlack
br chkWhite

chkBlack:
; This method will check legal moves of all black pieces.
; r2- current cell pointer.
; r3 - temporary row index (will be used once for another calculation).
; r5 - temporary column index (will be used once for another calculation).

mov r0, r3  ; Putting index of the current row in r3.
mov r1, r5  ; Putting index of the current column in r5.
mov #Board, r2 ; Putting board array starting index in r2.
mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bits).
mul #2, r5 ; Multiplying the number of column by 2 (decimal) (length of each column in bits).
add r3, r2 ;Adding the number of bits needed in order to point to a start of a row.
add r5, r2 ; Adding the number of bits needed in order to point a cell in a row.
; r2 will now contain the address of the current cell.
cmp (r2), #2 ; Checking if the current piece is black.
bne SkipCell ; If the color of the current piece is not black skip to the next cell.
mov r0, r3 ; Putting index of the current row in r3.
add #1, r3 ; Increasing row index by 1.
cmp r3, #7
bgt SkipCell ; If row index is bigger than 7, cannot move left, skip to the next cell.
mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
add #1, r5 ; Increasing column index by 1.
cmp r5, #7
bgt RightB1 ; If column index is bigger than 7, the current piece cannot move left, Check legal moves to the right.
cmp 18.(r2), #2 ; Checking if the lower right piece is black.
beq RightB1 ; If the lower right piece is black, cannot go there, Check legal moves to the right.
cmp 18.(r2), #1 ; Checking if the lower right piece is black.
beq eatlb1 ; If the lower right piece is white, check if the black piece can eat it.
add #1, 12.(sp) ; If we got here the lower right cell contains 0, the black piece can move there. Adding 1 to number of legal moves.
br canMove ;Found a legal move.

eatlb1:
;This method will check an eating option the left of black pieces.
; r2- current cell pointer.
; r3 - temporary row index .
; r5 - temporary column index.

add #1, r3 ; Increasing row index by 1.
cmp r3, #7 ; If r3 is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
bgt RightB1
add #1, r5 ;Increasing column index by 1.
cmp r5, #7
bgt RightB1 ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
;If we got here, the cell which the current black piece should be placed after eating is in the board bounds, we need to check if it is empty.
cmp 36.(r2), #0 ; Checking if the cell is empty.
bne RightB1 ; If the cell is not empty, cannot eat. Check legal moves to the right.
add #1, 12.(sp) ;If we got here, can eat. Adding 1 to number of legal moves.
br canMove ;Found a legal move.

RightB1:
; This method will check legal moves to the right of black pieces.
; r2- current cell pointer.
; r3 - temporary row index .
; r5 - temporary column index.

mov r0, r3 ; Putting index of the current row in r3.
add #1, r3 ; Increasing row index by 1.
mov r1, r5 ; Putting index of the current column in r5.
sub #1, r5 ; Decreasing column index by 1.
cmp r5, #0
blt SkipCell ; If column index is less than 0, cannot move right, skip to the next cell.
cmp 14.(r2), #2 ; Checking if the lower left piece is black.
beq SkipCell ; If the lower left piece is white, cannot move there, skip to the next cell.
cmp 14.(r2), #1 ; Checking if the lower left piece is white.
beq eatrb1 ; If the lower left piece is white, check if the black piece can eat it.
add #1, 12.(sp) ; If we got here the lower left cell contains 0, the black piece can move there. Adding 1 to number of legal moves.
br canMove ;Found a legal move.

eatrb1:
; This method will check an eating option the right of black pieces.
; r2- current cell pointer.
; r3 - temporary row index .
; r5 - temporary column index.

sub #1, r5 ; Reducing column index by 1.
cmp r5, #0
blt SkipCell ; If column index is less than 0, cannot eat, skip to the next cell.
add #1, r3 ; Increasing row index by 1.
cmp r3, #7
bgt SkipCell ; If r3 is bigger than 7, cannot eat (out of bounds). Skip to the next cell.
;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
cmp 28.(r2), #0 ; Checking if the cell is empty.
bne SkipCell ;If the cell is not empty, cannot eat. Skip to the next cell.
add #1, 12.(sp) ;If we got here, can eat. Adding 1 to number of legal moves.
br canMove ;Found a legal move.
; END OF hasMove




;==============================================================================
;                             END OF FUNCTIONS
;==============================================================================

.=torg + 15000
command: .blkw 25.
pointer: .blkw 1
curChar: .byte 1
.even
gameOn: .word 0
errorCom: .blkw 25.
errPtr: .blkw 1
putDolar: .word 0

turn: .word 1
source: .word 0
dest: .word 0
WinParam: .word 0
Steps: .word 0



wPlayer: .byte 0
.even
wTime: .word 0
wTimeStr: .blkw 25.
wTimePtr: .word 0
bPlayer: .byte 0
.even
bTime: .word 0
bTimeStr: .blkw 25.
bTimePtr: .word 0

.even
TIMOUT:.word 0
tcounter:.word 0

;========================================================================
;                            STRINGS
;========================================================================

.even
cannot: .ascii <Cannot\sexecute\s"\0>
dollar: .ascii <$ \0>
welcome:.ascii <Welcome\sto\s312433576\sand\s203438775\scheckers\sgame!\r>
newgame: .ascii<Starting\sa\snew\sgame\r>
Wplyris: .ascii<White\splayer\sis\s\0>
Bplyris: .ascii<Black\splayer\sis\s\0>
hmn: .ascii<Human\s\0>
computer: .ascii<Computer\s\0>
with: .ascii <with\s\0>
secpermov: .ascii< seconds\sper\smove\r>
boardlay: .ascii<Board layout:\r>
nlfeed: .ascii<\r>
CPStr: .ascii <Current\sPlayer:\s\0>
Blk: .ascii <Black\s\0>
Wht: .ascii <White\s\0>
movStr: .ascii <move\s\0>
tookStr: .ascii <took\s\0>
secStr: .ascii <seconds\0>
dotStr: .ascii <.\r>
gameOver: .ascii <is\sout\sof\stime.\sGame\sOver.\r>
wplyris: .ascii<white\splayer\sis\s\0>
bplyris: .ascii<black\splayer\sis\s\0>
WPfor: .ascii<WP\sfor\s\0>
playerWin: .ascii<player\swins!\r>

.even
Board:.word	0,	0,	0,	2,	0,	0,	0,	2
			.word	0,	0,	2,	0,	2,	0,	2,	0
			.word	0,	1,	0,	1,	0,	2,	0,	1
			.word	1,	0,	0,	0,	0,	0,	0,	0
			.word	0,	0,	0,	0,	0,	0,	0,	0
			.word	1,	0,	1,	0,	1,	0,	1,	0
			.word	0,	1,	0,	1,	0,	1,	0,	1
			.word	1,	0,	1,	0,	1,	0,	1,	0

NewBoard:
  .word	0,	2,	0,	2,	0,	2,	0,	2
	.word	2,	0,	2,	0,	2,	0,	2,	0
	.word	0,	2,	0,	2,	0,	2,	0,	2
	.word	0,	0,	0,	0,	0,	0,	0,	0
	.word	0,	0,	0,	0,	0,	0,	0,	0
	.word	1,	0,	1,	0,	1,	0,	1,	0
	.word	0,	1,	0,	1,	0,	1,	0,	1
	.word	1,	0,	1,	0,	1,	0,	1,	0

rate: .word 50.
