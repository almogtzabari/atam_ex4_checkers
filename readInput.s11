tks = 177560
tkb = 177562
tps = 177564
tpb = 177566
asciimask = 177760

.=torg + 60
.word rInput
.word 200

.=torg + 1000
main:
; Initializing stack
mov pc, sp
tst -(sp)
mov #welcome, -(sp)
jsr pc, printStr
tst (sp)+

mov #command, pointer
mov #101,@#tks ; keyboard interrupt = 1 && RE = 1
w:
cmp pointer, #command
bne cont
; Printing $
mov #dollar, -(sp)
jsr pc, printStr
tst (sp)+
cont:
wait
jmp w

; Read input
rInput:
movb @#tkb, curChar

; Check if we reached the end of the command
mov r0, -(sp) ; Backing up r0
mov #command, r0 ; Moving command string address to r0
add #50., r0 ; Adding max length of string to r0.
cmp pointer, r0 ; Checks if the command reached 50 chars.
bgt ignore
; We have not reached the end of the command
cmpb curChar, #'\r  ; checks if current char is ENTER
beq endOfIpt
cmpb #'\b, curChar  ; checks if current char is BackSpace
beq backspace
; Current char is a neither ENTER nor BackSpace
movb curChar, @pointer
movb curChar, @#tpb ; sending char to print
loop: tstb @#tps
bpl loop
; curChar was printed
inc pointer
mov (sp)+, r0 ; Restores r0.
inc @#tks ; RE = 1
rti

endOfIpt:
movb #'\n, @#tpb ; Prints Carrige Return/
w1:tstb @#tps
bpl w1
movb #'\r, @#tpb ; Prints LineFeed.
w2:tstb @#tps
bpl w2
movb #0, @pointer ; Adds linefeed to the command string.
mov #command, pointer ; Pointer will point the beginning of the command
mov (sp)+, r0 ; Restoring r0
jsr pc, decode ; Decoding the command
inc @#tks ; RE = 1
rti





backspace:
cmp #command, pointer
beq ignore
dec pointer
movb #'\b, @#tpb
wait0:		tstb @#tps
bpl wait0
movb #' , @#tpb
wait1:		tstb @#tps
bpl wait1
movb #'\b, @#tpb
wait2:		tstb @#tps
bpl wait2
inc @#tks ; RE = 1
mov (sp)+, r0 ; Restoring r0
rti
ignore:
mov (sp)+, r0 ; Restoring r0
inc @#tks ; RE = 1
rti

decode:
cmpb @pointer, #'s
beq sCom
cmpb @pointer, #'t
beq tCom
cmpb @pointer, #'m
beq mCom
jmp noCom

sCom:
inc pointer
cmpb @pointer, #'t
bne noCom
inc pointer
cmpb @pointer, #'a
beq staCom
cmpb @pointer, #'o
bne noCom
; If we got here we had the sequence 'sto'
inc pointer
cmpb @pointer, #'p
bne noCom
jmp stopCom

staCom:
; If we got here we had the sequence 'sta'
inc pointer
cmpb @pointer, #'r
bne noCom
inc pointer
cmpb @pointer, #'t
bne noCom
inc pointer
cmpb #' , @pointer
bne noCom
jmp startCom


tCom:
; If we got here we had 't'
inc pointer
cmpb @pointer, #'i
bne noCom
inc pointer
cmpb @pointer, #'m
bne noCom
inc pointer
cmpb @pointer, #'e
bne noCom
jmp timeCom

mCom:
; If we got here we had 'm'
inc pointer
cmpb @pointer, #'o
bne noCom
inc pointer
cmpb @pointer, #'v
bne noCom
inc pointer
cmpb @pointer, #'e
bne noCom
inc pointer
cmpb #' , @pointer
bne noCom
jmp moveCom

noCom:
; Prints cannot execute..
mov #cannot, -(sp)
jsr pc, printStr
tst (sp)+
mov #command, pointer
mov #errorCom, errPtr
cpyErr:
cmpb  #' , @pointer
beq donecpy
cmpb  #0 , @pointer
beq donecpy
movb @pointer, @errPtr
inc errPtr
inc pointer
jmp cpyErr

donecpy:
movb #'", @errPtr
inc errPtr
movb #'\r, @errPtr
mov #errorCom, -(sp)
jsr pc, printStr
tst (sp)+
mov #command, pointer
rts pc ; return from decode

startCom:
inc pointer
cmpb  #' , @pointer
beq startCom ; skipping spaces
; Spaces skipped
setWplyr:
cmpb @pointer, #'h
beq wHuman
cmpb @pointer, #'c
beq wPC
jmp noCom

wHuman:
mov #1, wPlayer
; Checks if after 'h' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer
bne noCom
dec pointer
jmp setwTime
wPC:
mov #2, wPlayer
; Checks if after 'c' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer
bne noCom
dec pointer
jmp setwTime

setwTime:
mov #0, wTime
inc pointer
cmpb #' , @pointer
beq setwTime ; skipping spaces
cmpb @pointer, #'0
blt noCom ; jumps if not a number
cmpb @pointer, #'9
bgt noCom ; jumps if not a number
; If we got here it is a number
rdWTime: ; Read White player time
mov r1, -(sp) ; Backing up r1
mov wTime, r1
mul #10., r1
mov r1, wTime
mov (sp)+, r1
mov r0, -(sp) ; Backing up r0
movb @pointer, r0
bic #asciimask, r0
add r0, wTime
mov (sp)+, r0
inc pointer
cmpb #' , @pointer
beq setBplyr
cmpb @pointer, #'0
blt jnoCom ; jumps if not a number
cmpb @pointer, #'9
bgt jnoCom ; jumps if not a number
jmp rdWTime

setBplyr:
inc pointer
cmpb  #' , @pointer
beq setBplyr ; skipping spaces
cmpb @pointer, #'h
beq bHuman
cmpb @pointer, #'c
beq bPC
jmp noCom

bHuman:
mov #1, bPlayer
; Checks if after 'h' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer
bne jnoCom
dec pointer
jmp setbTime

bPC:
mov #2, bPlayer
; Checks if after 'c' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer
bne jnoCom
dec pointer
jmp setbTime

                          jnoCom: jmp noCom

setbTime:
mov #0, bTime
inc pointer
cmpb #' , @pointer
beq setbTime ; skipping spaces
cmpb @pointer, #'0
blt jnoCom ; jumps if not a number
cmpb  @pointer, #'9
bgt jnoCom ; jumps if not a number
; If we got here it is a number
rdBTime: ; Read Black player time
mov r1, -(sp) ; Backing up r1
mov bTime, r1
mul #10., r1
mov r1, bTime
mov (sp)+, r1
mov r0, -(sp) ; Backing up r0
movb @pointer, r0
bic #asciimask, r0
add r0, bTime
mov (sp)+, r0
inc pointer
cmpb @pointer, #'0
blt startChk ; jumps if not a number
cmpb @pointer, #'9
bgt startChk ; jumps if not a number
jmp rdBTime

startChk:
cmpb @pointer, #0
beq startOK
jmp noCom

startOK:
jsr pc, Start
rts pc

Start:
mov #newgame, -(sp)
jsr pc, printStr
tst (sp)+
rts pc

stopCom: halt
timeCom: halt
moveCom: halt


  ;========================================================================
  ;                            FUNCTIONS
  ;========================================================================

  printStr:
  tstb @#tps ;Busy wait, wait till end of print.
  bpl printStr
  cmpb #'\0, @2(sp) ; Check if reached end of string.
  beq sof
  cmpb #'\r, @2(sp) ;Check if reached end of string and needs to print a new line.
  beq newline
  movb @2(sp), @#tpb ;Print char.
  inc 2(sp) ; Move to the next char.
  br printStr
  newline:
  tstb @#tps ;Busy wait, wait till end of print.
  bpl newline
  movb #'\r, @#tpb ;Prints carrige return.
  wx: tstb @#tps ;Busy wait, wait till end of print.
  bpl wx
  movb #'\n, @#tpb ; Prints a new line.
  wz: tstb @#tps ;Busy wait, wait till end of print.
  bpl wz
  sof:
  rts pc

.=torg + 3000
command: .blkw 25.
pointer: .blkw 1
curChar: .byte 1
.even
errorCom: .blkw 25.
errPtr: .blkw 1


wPlayer: .byte 0
.even
wTime: .word 0
bPlayer: .byte 0
.even
bTime: .word 0

.even
TIMOUT:.word 1

;========================================================================
;                            STRINGS
;========================================================================

.even
cannot: .ascii <Cannot\sexecute\s"\0>
dollar: .ascii <$ \0>
welcome:.ascii <Welcome\sto\s312433576\sand\s203438775\scheckers\sgame!\r>
newgame: .ascii<Starting\sa\snew\sgame\r>
wplyris: .ascii<White\splayer\sis\s\0>
hmn: .ascii<Human\s\0>
