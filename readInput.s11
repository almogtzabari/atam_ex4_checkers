tks = 177560
tkb = 177562
tps = 177564
tpb = 177566
asciimask = 177760

.=torg + 60
.word rInput
.word 200

.=torg + 1000
main:
; Initializing stack
mov pc, sp
tst -(sp)
mov #welcome, -(sp)
jsr pc, printStr
tst (sp)+

mov #command, pointer
mov #101,@#tks ; keyboard interrupt = 1 && RE = 1
w:
cmp pointer, #command
bne cont
; Printing $
mov #dollar, -(sp)
jsr pc, printStr
tst (sp)+
cont:
wait
jmp w

; Read input
rInput:
movb @#tkb, curChar

; Check if we reached the end of the command
mov r0, -(sp) ; Backing up r0
mov #command, r0 ; Moving command string address to r0
add #50., r0 ; Adding max length of string to r0.
cmp pointer, r0 ; Checks if the command reached 50 chars.
bgt ignore
; We have not reached the end of the command
cmpb curChar, #'\r  ; checks if current char is ENTER
beq endOfIpt
cmpb #'\b, curChar  ; checks if current char is BackSpace
beq backspace
; Current char is a neither ENTER nor BackSpace
movb curChar, @pointer
movb curChar, @#tpb ; sending char to print
loop: tstb @#tps
bpl loop
; curChar was printed
inc pointer
mov (sp)+, r0 ; Restores r0.
inc @#tks ; RE = 1
rti

endOfIpt:
movb #'\n, @#tpb ; Prints Carrige Return/
w1:tstb @#tps
bpl w1
movb #'\r, @#tpb ; Prints LineFeed.
w2:tstb @#tps
bpl w2
movb #0, @pointer ; Adds linefeed to the command string.
mov #command, pointer ; Pointer will point the beginning of the command
mov (sp)+, r0 ; Restoring r0
jsr pc, decode ; Decoding the command
inc @#tks ; RE = 1
rti





backspace:
cmp #command, pointer
beq ignore
dec pointer
movb #'\b, @#tpb
wait0:		tstb @#tps
bpl wait0
movb #' , @#tpb
wait1:		tstb @#tps
bpl wait1
movb #'\b, @#tpb
wait2:		tstb @#tps
bpl wait2
inc @#tks ; RE = 1
mov (sp)+, r0 ; Restoring r0
rti
ignore:
mov (sp)+, r0 ; Restoring r0
inc @#tks ; RE = 1
rti

decode:
cmpb @pointer, #'s
beq sCom
cmpb @pointer, #'t
beq tCom
cmpb @pointer, #'m
beq mCom
jmp noCom

sCom:
inc pointer
cmpb @pointer, #'t
bne noCom
inc pointer
cmpb @pointer, #'a
beq staCom
cmpb @pointer, #'o
bne noCom
; If we got here we had the sequence 'sto'
inc pointer
cmpb @pointer, #'p
bne noCom
jmp stopCom

staCom:
; If we got here we had the sequence 'sta'
inc pointer
cmpb @pointer, #'r
bne noCom
inc pointer
cmpb @pointer, #'t
bne noCom
inc pointer
cmpb #' , @pointer
bne noCom
jmp startCom


tCom:
; If we got here we had 't'
inc pointer
cmpb @pointer, #'i
bne noCom
inc pointer
cmpb @pointer, #'m
bne noCom
inc pointer
cmpb @pointer, #'e
bne noCom
jmp timeCom

mCom:
; If we got here we had 'm'
inc pointer
cmpb @pointer, #'o
bne noCom
inc pointer
cmpb @pointer, #'v
bne noCom
inc pointer
cmpb @pointer, #'e
bne noCom
inc pointer
cmpb #' , @pointer
bne noCom
jmp moveCom

noCom:
; Prints cannot execute..
mov #cannot, -(sp)
jsr pc, printStr
tst (sp)+
mov #command, pointer
mov #errorCom, errPtr
cpyErr:
cmpb  #' , @pointer
beq donecpy
cmpb  #0 , @pointer
beq donecpy
movb @pointer, @errPtr
inc errPtr
inc pointer
jmp cpyErr

donecpy:
movb #'", @errPtr
inc errPtr
movb #'\r, @errPtr
mov #errorCom, -(sp)
jsr pc, printStr
tst (sp)+
mov #command, pointer
rts pc ; return from decode

startCom:
inc pointer
cmpb  #' , @pointer
beq startCom ; skipping spaces
; Spaces skipped
setWplyr:
cmpb @pointer, #'h
beq wHuman
cmpb @pointer, #'c
beq wPC
jmp noCom

wHuman:
mov #1, wPlayer
; Checks if after 'h' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer
bne noCom
dec pointer
jmp setwTime
wPC:
mov #2, wPlayer
; Checks if after 'c' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer
bne noCom
dec pointer
jmp setwTime

setwTime:
mov #0, wTime
inc pointer
cmpb #' , @pointer
beq setwTime ; skipping spaces
cmpb @pointer, #'0
blt noCom ; jumps if not a number
cmpb @pointer, #'9
bgt noCom ; jumps if not a number
; If we got here it is a number
rdWTime: ; Read White player time
mov r1, -(sp) ; Backing up r1
mov wTime, r1
mul #10., r1
mov r1, wTime
mov (sp)+, r1
mov r0, -(sp) ; Backing up r0
movb @pointer, r0
bic #asciimask, r0
add r0, wTime
mov (sp)+, r0
inc pointer
cmpb #' , @pointer
beq setBplyr
cmpb @pointer, #'0
blt jnoCom ; jumps if not a number
cmpb @pointer, #'9
bgt jnoCom ; jumps if not a number
jmp rdWTime

setBplyr:
inc pointer
cmpb  #' , @pointer
beq setBplyr ; skipping spaces
cmpb @pointer, #'h
beq bHuman
cmpb @pointer, #'c
beq bPC
jmp noCom

bHuman:
mov #1, bPlayer
; Checks if after 'h' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer
bne jnoCom
dec pointer
jmp setbTime

bPC:
mov #2, bPlayer
; Checks if after 'c' there is a space. if not -> noCom
inc pointer
cmpb #' , @pointer
bne jnoCom
dec pointer
jmp setbTime

                          jnoCom: jmp noCom

setbTime:
mov #0, bTime
inc pointer
cmpb #' , @pointer
beq setbTime ; skipping spaces
cmpb @pointer, #'0
blt jnoCom ; jumps if not a number
cmpb  @pointer, #'9
bgt jnoCom ; jumps if not a number
; If we got here it is a number
rdBTime: ; Read Black player time
mov r1, -(sp) ; Backing up r1
mov bTime, r1
mul #10., r1
mov r1, bTime
mov (sp)+, r1
mov r0, -(sp) ; Backing up r0
movb @pointer, r0
bic #asciimask, r0
add r0, bTime
mov (sp)+, r0
inc pointer
cmpb @pointer, #'0
blt startChk ; jumps if not a number
cmpb @pointer, #'9
bgt startChk ; jumps if not a number
jmp rdBTime

startChk:
cmpb @pointer, #0
beq startOK
jmp noCom

startOK:
jsr pc, Start
rts pc

Start:
mov #newgame, -(sp)
jsr pc, printStr
tst (sp)+
rts pc

stopCom: halt
timeCom: halt
moveCom:
  inc pointer
  cmpb  #' , @pointer
  beq moveCom ; Skipping spaces.
  cmpb #'0 , @pointer
  blt noCom
  cmpb #'7 , @pointer
  bgt noCom
  mov r0, -(sp) ; Backing up r0.
  mov r1, -(sp) ; Backing up r1.
  clr r1
  mov @pointer, r0
  bic #asciimask, r0
  add r0, r1
  inc pointer ;Get next index character.
  cmpb #'0 , @pointer
  blt badIdx
  cmpb #'7 , @pointer
  bgt badIdx
  mov @pointer, r0
  bic #asciimask, r0
  add r0, r1
  mul #2, r1 ;Multiplying by 2 (each word is 2 bytes).
  add #Board, r1
  mov r1, source
  ; r1 now hold source board adress.
  cmp (r1), @turn ;Checks if a piece of the current player is found in the given index.
  bne badIdx
  inc pointer
  skip:
  cmpb  #' , @pointer
  beq skip ; Skipping spaces.
  cmpb #'0 , @pointer
  blt badIdx
  cmpb #'7 , @pointer
  bgt badIdx
  clr r1
  mov @pointer, r0
  bic #asciimask, r0
  add r0, r1
  inc pointer ;Get next index character.
  cmpb #'0 , @pointer
  blt badIdx
  cmpb #'7 , @pointer
  bgt badIdx
  mov @pointer, r0
  bic #asciimask, r0
  add r0, r1
  mul #2, r1 ;Multiplying by 2 (each word is 2 bytes).
  add #Board, r1
  mov r1, dest
  ;dest will now hold desteation board adress.
  cmp dest, source
  beq badIdx ; Checks if source == dest.
  cmp #1, turn
  bne bIdxChk
  ;Checking if the desteation index is legal for white player.
  cmp source, dest
  blt badIdx ; If source<dest white is trying to move down instead of up.
  clr r1
  clr r0
  add source, r1
  add dest, r1 ; r1 = source address + dest address
  div #2, r0  ; r0 will hold the address of the eaten cell in case of eat.
  mov r0, -(sp) ; Backing up the address of the eaten cell.
  ; Now we have the potenitally eaten cell address. we need to check if
  ; that eaten cell address is a multiply of 2.
  clr r0
  mov (sp)+, r1 ; r1 = eaten cell address.
  div #2, r0 ; r1 will hold the remainer.
  cmp r1, #0 ; if the remainder is zero there was an eat.
  beq wEatChk
  ;If we got here there was no eat.
  mov source, r0
  sub 18., r0
  cmp dest, r0 ;Checks if dest is the upper left cell.
  blt badIdx ;branch to bad index if dest has smaller adress than the upper right cell (lowest legal adress).
  ; If we got here dest can be the upper right cell or any other cell that has bigger adress.
  add #4, r0 ;Gets the address of the upper right cell.
  cmp dest, r0 ;Checks if dest is the upper right cell.
  bgt badIdx
  ; If we got here dest can be the upper right cell, the upper left cell or the upper (middle) cell.
  sub #2, r0 ; Gets the adress of the upper (middle) cell.
  cmp dest, r0
  beq badIdx
  ; If we got here dest is the upper right cell or the upper left cell.
  cmp dest, #0 ; Checks if the piece can move from source to dest.
  bne badIdx
  mov (sp)+, r1 ;Restores r1's value.
  mov (sp)+, r0 ;Restores r0's value.
  mov source, -(sp)
  mov dest -(sp)
  jsr pc, movPiece
  add #4, sp ;Popping source and dest.
  rti



wEatChk:
  mov source, r0
  sub 36., r0
  cmp dest, r0 ;Checks if dest is the upper left cell.
  blt badIdx ;branch to bad index if dest has smaller adress than the upper left cell (lowest legal adress).
  ; If we got here dest can be the upper left cell or any other cell that has bigger adress.
  add #4, r0 ;Gets the address of the upper right cell.
  cmp dest, r0 ;Checks if dest is the upper right cell.
  bgt badIdx
  ; If we got here dest can be the upper right cell, the upper left cell or the upper (middle) cell.
  sub #2, r0 ; Gets the adress of the upper (middle) cell.
  cmp dest, r0
  beq badIdx
  ; If we got here dest is the upper right cell or the upper left cell.
  cmp dest, #0 ; Checks if the piece can move from source to dest.
  bne badIdx
  mov source, r1
  add dest, r1 ; r1 = source address + dest address
  div #2, r0  ; r0 will hold the address of the eaten cell in case of eat.
  cmp (r0), #2 ; Checks if there's a black piece to eat.
  bne badIdx
  mov (sp)+, r1 ;Restores r1's value.
  mov (sp)+, r0 ;Restores r0's value.
  mov source, -(sp)
  mov dest -(sp)
  jsr pc, movPiece
  add #4, sp ;Popping source and dest.
  rti



bIdxChk:
  ;Checking if the desteation index is legal for white player.
  cmp source, dest
  bgt badIdx ; If source>dest black is trying to move up instead of down.
  clr r1
  clr r0
  add source, r1
  add dest, r1 ; r1 = source address + dest address
  div #2, r0  ; r0 will hold the address of the eaten cell in case of eat.
  mov r0, -(sp) ; Backing up the address of the eaten cell.
  ; Now we have the potenitally eaten cell address. we need to check if
  ; that eaten cell address is a multiply of 2.
  clr r0
  mov (sp)+, r1 ; r1 = eaten cell address.
  div #2, r0 ; r1 will hold the remainer.
  cmp r1, #0 ; if the remainder is zero there was an eat.
  beq bEatChk
  ;If we got here there was no eat.
  mov source, r0
  add 14., r0
  cmp dest, r0 ;Checks if dest is the lower left cell.
  blt badIdx ;branch to bad index if dest has smaller adress than the lower right cell (lowest legal adress).
  ; If we got here dest can be the lower right cell or any other cell that has bigger adress.
  add #4, r0 ;Gets the address of the lower right cell.
  cmp dest, r0 ;Checks if dest is the lower right cell.
  bgt badIdx
  ; If we got here dest can be the lower right cell, the lower left cell or the lower (middle) cell.
  sub #2, r0 ; Gets the adress of the lower (middle) cell.
  cmp dest, r0
  beq badIdx
  ; If we got here dest is the lower right cell or the lower left cell.
  cmp dest, #0 ; Checks if the piece can move from source to dest.
  bne badIdx
  mov (sp)+, r1 ;Restores r1's value.
  mov (sp)+, r0 ;Restores r0's value.
  mov source, -(sp)
  mov dest -(sp)
  jsr pc, movPiece
  add #4, sp ;Popping source and dest.
  rti



bEatChk:
  mov source, r0
  add 28., r0
  cmp dest, r0 ;Checks if dest is the lower left cell.
  blt badIdx ;branch to bad index if dest has smaller adress than the lower left cell (lowest legal adress).
  ; If we got here dest can be the lower left cell or any other cell that has bigger adress.
  add #4, r0 ;Gets the address of the lower right cell.
  cmp dest, r0 ;Checks if dest is the lower right cell.
  bgt badIdx
  ; If we got here dest can be the lower right cell, the lower left cell or the lower (middle) cell.
  sub #2, r0 ; Gets the adress of the lower (middle) cell.
  cmp dest, r0
  beq badIdx
  ; If we got here dest is the lower right cell or the lower left cell.
  cmp dest, #0 ; Checks if the piece can move from source to dest.
  bne badIdx
  mov source, r1
  add dest, r1 ; r1 = source address + dest address
  div #2, r0  ; r0 will hold the address of the eaten cell in case of eat.
  cmp (r0), #1 ; Checks if there's a white piece to eat.
  bne badIdx
  mov (sp)+, r1 ;Restores r1's value.
  mov (sp)+, r0 ;Restores r0's value.
  mov source, -(sp)
  mov dest -(sp)
  jsr pc, movPiece
  add #4, sp ;Popping source and dest.
  rti

  badIdx:
    mov (sp)+, r1
    mov (sp)+, r0
    jmp noCom






  ;========================================================================
  ;                            FUNCTIONS
  ;========================================================================

  printStr:
  tstb @#tps ;Busy wait, wait till end of print.
  bpl printStr
  cmpb #'\0, @2(sp) ; Check if reached end of string.
  beq sof
  cmpb #'\r, @2(sp) ;Check if reached end of string and needs to print a new line.
  beq newline
  movb @2(sp), @#tpb ;Print char.
  inc 2(sp) ; Move to the next char.
  br printStr
  newline:
  tstb @#tps ;Busy wait, wait till end of print.
  bpl newline
  movb #'\r, @#tpb ;Prints carrige return.
  wx: tstb @#tps ;Busy wait, wait till end of print.
  bpl wx
  movb #'\n, @#tpb ; Prints a new line.
  wz: tstb @#tps ;Busy wait, wait till end of print.
  bpl wz
  sof:
  rts pc


  ; This method will move a player from the source position to the destanation
  ; position.
  ;
  ; Input:
  ; 1. Source position - will be stored at 2(sp).
  ; 2. Destanation position - will be stored at 4(sp).


movPiece:
 mov r1, -(sp) ; Backing up  r1.
 mov r3, -(sp) ; Backing up  r3.
 mov 2(sp), r1 ; r1 = Adress of source position.
 mov 4(sp), r3 ; r3 = Adress of destanation position.

 ; Making the changes.
 mov (r1), (r3) ; board[dest] = board[source].
 mov #0, (r1) ; board[source] = 0.

 ; Now we need to check if there was an eat. We will find the address
 ; in the middle between the source address and the dest address.
 ; Notice that if there was an eat then the address of the eaten cell
 ; is a multiply of 2 and is equal to: (src_addr + dest_addr)/2 .
 ; In that case we also need to put 0 in that place.
 ; If there was no eat then the address of the middle cell is not a
 ; multiply of 2 and so we need to finish the function.
 mov r0, -(sp) ; Backing up r0.
 clr r0
 add r3, r1 ; r1 = source address + dest address
 div #2, r0  ; r0 will hold the address of the eaten cell in case of eat.
 mov r0, -(sp) ; Backing up the address of the eaten cell.
 ; Now we have the potenitally eaten cell address. we need to check if
 ; that eaten cell address is a multiply of 2.
clr r0
 mov (sp), r1 ; r1 = eaten cell address.
 div #2, r0 ; r1 will hold the remainer.
 cmp r1, #0 ;
 bne endmop ; if the remainer is not zero there was no eat. goto endmop.
 ; If we got here then the remainer is zero. it means that there was an
 ; eat and we need to put 0 in the eaten place.
 ; Notice that the eaten cell address is at sp.
 mov #0, @(sp)
 ; Method is done. Restoring registers.
 endmop:
tst (sp)+ ; popping the eaten cell address (no longer needed).
mov (sp)+, r0 ; Restoring value of r0.
mov (sp)+, r3 ; Restoring value of r4.
mov (sp)+, r1 ; Restoring value of r3.
rts pc

.=torg + 3000
command: .blkw 25.
pointer: .blkw 1
curChar: .byte 1
.even
errorCom: .blkw 25.
errPtr: .blkw 1


wPlayer: .byte 0
.even
wTime: .word 0
bPlayer: .byte 0
.even
bTime: .word 0

.even
TIMOUT:.word 1

;========================================================================
;                            STRINGS
;========================================================================

.even
cannot: .ascii <Cannot\sexecute\s"\0>
dollar: .ascii <$ \0>
welcome:.ascii <Welcome\sto\s312433576\sand\s203438775\scheckers\sgame!\r>
newgame: .ascii<Starting\sa\snew\sgame\r>
wplyris: .ascii<White\splayer\sis\s\0>
hmn: .ascii<Human\s\0>
